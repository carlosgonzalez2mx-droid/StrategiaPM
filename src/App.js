import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { debounce } from 'lodash';
import './App.css';
import './index.css';

// Componentes
import LoginForm from './components/LoginForm';
import ProtectedRoute from './components/ProtectedRoute';
import Sidebar from './components/Sidebar';
import ConsolidatedDashboard from './components/ConsolidatedDashboard';
import IntegratedPMODashboard from './components/IntegratedPMODashboard';
import PortfolioStrategic from './components/PortfolioStrategic';
import ProjectManagementTabs from './components/ProjectManagementTabs';
import ScheduleManagement from './components/ScheduleManagement';
import FinancialManagement from './components/FinancialManagement';
import ResourceManagement from './components/ResourceManagement';
import RiskManagement from './components/RiskManagement';
import ChangeManagement from './components/ChangeManagement';
import CashFlowProjection from './components/CashFlowProjection';
import FileManager from './components/FileManager';
import ReportsManagement from './components/ReportsManagement';
import ProjectAudit from './components/ProjectAudit';
import ProjectArchive from './components/ProjectArchive';
import SyncIndicator from './components/SyncIndicator';
import BackupManager from './components/BackupManager';
import FileStatusIndicator from './components/FileStatusIndicator';
import AutoSaveIndicator from './components/AutoSaveIndicator';
import SupabaseAuth from './components/SupabaseAuth';
import OrganizationMembers from './components/OrganizationMembers';
import UserManagement from './components/UserManagement';
import SplashScreen from './components/SplashScreen';

// Super Admin Components
import SuperAdminRoute from './components/admin/SuperAdminRoute';
import SuperAdminDashboard from './components/admin/SuperAdminDashboard';
import OrganizationDetails from './components/admin/OrganizationDetails';

import filePersistenceService from './services/FilePersistenceService';
import supabaseService from './services/SupabaseService';

// Contextos
import { AuthProvider, useAuth } from './contexts/AuthContext';
import { ProjectProvider } from './contexts/ProjectContext';

// Hooks
import usePermissions from './hooks/usePermissions';

// Funci√≥n de ordenamiento de tareas por wbsCode (importada desde ScheduleManagement)
const sortTasksByWbsCode = (tasks) => {
  return [...tasks].sort((a, b) => {
    // Funci√≥n mejorada para manejar diferentes formatos de wbsCode
    const getNumericValue = (wbsCode) => {
      if (!wbsCode) return 0;
      
      // Si es un n√∫mero directo
      if (typeof wbsCode === 'number') return wbsCode;
      
      // Si es string, extraer solo los n√∫meros
      const numericMatch = String(wbsCode).match(/\d+/);
      if (numericMatch) {
        return parseInt(numericMatch[0], 10);
      }
      
      // Si contiene "Sin predecesoras" o similar, poner al final
      if (String(wbsCode).toLowerCase().includes('sin')) return 999999;
      
      return 0;
    };
    
    const aNum = getNumericValue(a.wbsCode);
    const bNum = getNumericValue(b.wbsCode);
    
    // Si los n√∫meros son iguales, mantener orden original
    if (aNum === bNum) {
      return 0;
    }
    
    return aNum - bNum;
  });
};

// Componente principal de la aplicaci√≥n (requiere autenticaci√≥n)
function MainApp() {
  const { user, showSplash, completeSplash } = useAuth();
  
  // Hook de permisos para detectar usuarios de solo lectura
  const { isReadOnly, userRole, isLoading: permissionsLoading } = usePermissions();
  
  // Cargar script de diagn√≥stico solo en desarrollo
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      import('./debug-file-storage').catch(err => {
        console.warn('No se pudo cargar el script de diagn√≥stico:', err);
      });
    }
  }, []);
  
  // ===== ESTADO MULTI-PROYECTO =====
  const [projects, setProjects] = useState([
    // Proyecto de demostraci√≥n para familiarizarse con el sistema
    {
      id: 'demo-001',
      name: 'Proyecto de Demostraci√≥n',
      description: 'Proyecto de ejemplo para familiarizarse con el sistema. Puede eliminarse cuando agregue sus proyectos reales.',
      status: 'active',
      priority: 'medium',
      startDate: new Date().toISOString().split('T')[0],
      endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 d√≠as desde hoy
      budget: 100000,
      contingencyReserve: 10000,
      managementReserve: 5000,
      manager: 'Usuario Demo',
      sponsor: 'Organizaci√≥n',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: '1.0.0',
      progress: 0,
      organizationId: 'demo-org-001' // CORRECCI√ìN: Agregar organizationId para compatibilidad con localStorage
    }
  ]);

  // Funci√≥n para obtener el proyecto inicial con l√≥gica de respaldo
  const getInitialProjectId = () => {
    // 1. Intentar cargar el √∫ltimo proyecto seleccionado desde localStorage
    const lastSelectedProjectId = localStorage.getItem('lastSelectedProjectId');
    
    if (lastSelectedProjectId) {
      // Verificar si el proyecto a√∫n existe y est√° activo
      const project = projects.find(p => p.id === lastSelectedProjectId);
      if (project && project.status === 'active') {
        return lastSelectedProjectId;
      }
    }
    
    // 2. Si no hay proyecto seleccionado o no est√° activo, buscar el primer proyecto activo
    const activeProject = projects.find(p => p.status === 'active');
    if (activeProject) {
      return activeProject.id;
    }
    
    // 3. Si no hay proyectos activos, usar el primer proyecto disponible
    if (projects.length > 0) {
      return projects[0].id;
    }
    
    // 4. Fallback por defecto
    return 'demo-001';
  };

  const [currentProjectId, setCurrentProjectId] = useState(getInitialProjectId);
  const [portfolioViewMode, setPortfolioViewMode] = useState('portfolio'); // 'portfolio', 'project', 'schedule'
  const [viewMode, setViewMode] = useState('dashboard');
  
  // Estado para controlar el modo de persistencia
  const [useSupabase, setUseSupabase] = useState(false);
  const [supabaseInitialized, setSupabaseInitialized] = useState(false);
  const [showAuthModal, setShowAuthModal] = useState(false);

  // Corregir currentProjectId si no coincide con ning√∫n proyecto existente
  useEffect(() => {
    if (projects && projects.length > 0) {
      const projectExists = projects.find(p => p.id === currentProjectId);
      if (!projectExists) {
        // Buscar el primer proyecto activo disponible
        const activeProject = projects.find(p => p.status === 'active');
        const fallbackProjectId = activeProject ? activeProject.id : projects[0].id;
        
        console.log('üîß CORRIGIENDO currentProjectId:', {
          currentProjectId,
          availableProjects: projects.map(p => ({ id: p.id, name: p.name, status: p.status })),
          fallbackTo: fallbackProjectId,
          reason: 'Proyecto no encontrado, usando primer proyecto disponible'
        });
        setCurrentProjectId(fallbackProjectId);
      }
    }
  }, [projects, currentProjectId]);

  // Work Packages eliminados - ya no se usan

  // Tareas por proyecto - cada proyecto tiene su propio cronograma
  const [tasksByProject, setTasksByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin tareas iniciales
  });

  // Configuraci√≥n de d√≠as laborables por proyecto - cada proyecto puede tener su propia configuraci√≥n
  const [includeWeekendsByProject, setIncludeWeekendsByProject] = useState({
    'demo-001': false // Por defecto: solo d√≠as laborales (lunes a viernes)
  });

  // Funci√≥n para limpiar datos corruptos - CON MONITOREO INTELIGENTE
  const cleanTasksByProject = (data) => {
    if (!data || typeof data !== 'object') {
      console.warn('üö® CORRUPCI√ìN REAL: data no es un objeto v√°lido');
      return {};
    }
    
    const cleaned = {};
    let hasRealCorruption = false;
    let corruptionDetails = [];
    
    Object.keys(data).forEach(projectId => {
      const projectTasks = data[projectId];
      
      // Detectar corrupci√≥n REAL (no arrays v√°lidos)
      if (typeof projectTasks === 'function') {
        console.warn(`üö® CORRUPCI√ìN REAL detectada en proyecto ${projectId}: funci√≥n en lugar de array`);
        corruptionDetails.push(`${projectId}: funci√≥n`);
        cleaned[projectId] = [];
        hasRealCorruption = true;
      } else if (projectTasks && !Array.isArray(projectTasks) && typeof projectTasks === 'object' && projectTasks.constructor !== Array) {
        console.warn(`üö® CORRUPCI√ìN REAL detectada en proyecto ${projectId}: objeto no-array`);
        corruptionDetails.push(`${projectId}: objeto no-array`);
        cleaned[projectId] = [];
        hasRealCorruption = true;
      } else {
        // Datos v√°lidos - mantener tal como est√°n
        cleaned[projectId] = projectTasks;
      }
    });
    
    if (hasRealCorruption) {
      console.warn(`üö® CORRUPCI√ìN REAL detectada y corregida:`, corruptionDetails);
      // Crear backup antes de limpiar
      const backup = JSON.stringify(data);
      localStorage.setItem('corruption-backup-' + Date.now(), backup);
      console.log('üíæ Backup de datos corruptos creado');
    } else {
      console.log('‚úÖ Datos v√°lidos, sin limpieza necesaria');
    }
    
    return cleaned;
  };

  // Funci√≥n para obtener tareas del proyecto actual
  const getCurrentProjectTasks = () => {
    // Obtener tareas directamente sin limpiar datos corruptos aqu√≠
    // La limpieza se hace solo una vez al cargar datos iniciales
    const tasks = tasksByProject[currentProjectId] || [];
    
    // DEBUG: Logging detallado para identificar mezcla de proyectos
    console.log(`üîç getCurrentProjectTasks - Proyecto ${currentProjectId}:`, {
      currentProjectId,
      tasksCount: tasks.length,
      tasksWithDifferentProjects: tasks.filter(t => t.projectId && t.projectId !== currentProjectId).length,
      sampleTasks: tasks.slice(0, 3).map(t => ({
        id: t.id,
        name: t.name,
        projectId: t.projectId,
        startDate: t.startDate,
        endDate: t.endDate,
        cost: t.cost,
        isMilestone: t.isMilestone
      })),
      tasksWithCosts: tasks.filter(t => t.cost > 0).length,
      tasksWithCostsDetails: tasks.filter(t => t.cost > 0).map(t => ({
        id: t.id,
        name: t.name,
        startDate: t.startDate,
        endDate: t.endDate,
        cost: t.cost,
        isMilestone: t.isMilestone
      }))
    });
    
    // Solo loggear si hay un problema potencial
    if (!Array.isArray(tasks)) {
      console.warn('‚ö†Ô∏è Datos corruptos detectados en getCurrentProjectTasks:', {
        currentProjectId,
        tasksType: typeof tasks,
        tasksValue: tasks
      });
      return []; // Retornar array vac√≠o si hay datos corruptos
    }
    
    return tasks;
  };

  // Ref para controlar si ya se limpiaron los datos corruptos
  const dataCleanedRef = useRef(false);

  // Limpiar datos corruptos SOLO al cargar datos iniciales, no en useEffect
  const cleanCorruptDataOnce = useCallback(() => {
    if (!dataCleanedRef.current && tasksByProject && typeof tasksByProject === 'object' && !Array.isArray(tasksByProject) && Object.keys(tasksByProject).length > 0) {
      // Verificar si hay datos corruptos antes de limpiar
      let hasCorruptData = false;
      for (const [projectId, tasks] of Object.entries(tasksByProject)) {
        if (typeof tasks === 'function' || (tasks && !Array.isArray(tasks))) {
          hasCorruptData = true;
          console.warn('‚ö†Ô∏è Datos corruptos detectados en tasksByProject para proyecto:', projectId, 'tipo:', typeof tasks);
          break;
        }
      }
      
      if (hasCorruptData) {
        const cleanedTasksByProject = cleanTasksByProject(tasksByProject);
        if (cleanedTasksByProject !== tasksByProject) {
          console.warn('‚ö†Ô∏è Datos corruptos detectados en tasksByProject, limpiando...');
          safeSetTasksByProject(cleanedTasksByProject);
        }
      }
      dataCleanedRef.current = true; // Marcar como limpiado SIEMPRE
    }
  }, [tasksByProject]);

  // Sistema de auto-guardado con debouncing
  const debouncedSave = useCallback(
    debounce(async (dataToSave) => {
      if (!useSupabase || !supabaseService.isAuthenticated()) {
        console.log('‚è≠Ô∏è Saltando guardado - No autenticado o Supabase deshabilitado');
        return;
      }
      
      console.log('üíæ Auto-guardando cambios...');
      const saveStartTime = Date.now();
      
      try {
        const success = await supabaseService.savePortfolioData(dataToSave);
        
        if (success) {
          const duration = Date.now() - saveStartTime;
          console.log(`‚úÖ Auto-guardado exitoso en ${duration}ms`);
          
          // Disparar evento para actualizar UI
          const event = new CustomEvent('autoSaveComplete', { 
            detail: { duration, timestamp: new Date().toISOString() } 
          });
          window.dispatchEvent(event);
        } else {
          console.warn('‚ö†Ô∏è Auto-guardado fall√≥');
        }
      } catch (error) {
        console.error('‚ùå Error en auto-guardado:', error);
      }
    }, 2000), // Esperar 2 segundos despu√©s del √∫ltimo cambio
    [useSupabase]
  );

  // Cancelar guardado pendiente al desmontar
  useEffect(() => {
    return () => {
      debouncedSave.cancel();
    };
  }, [debouncedSave]);

  // Ref para prevenir actualizaciones simult√°neas
  const isUpdatingTasksRef = useRef(false);
  const isUpdatingTasksByProjectRef = useRef(false);

  // Funci√≥n wrapper segura para setTasksByProject
  const safeSetTasksByProject = useCallback((newTasksByProject) => {
    // PREVENIR ACTUALIZACIONES SIMULT√ÅNEAS DE TASKSBYPROJECT
    if (isUpdatingTasksByProjectRef.current) {
      console.warn('‚ö†Ô∏è safeSetTasksByProject - ACTUALIZACI√ìN EN PROGRESO, OMITIENDO');
      return;
    }

    console.log('üìä safeSetTasksByProject - INICIANDO:', {
      newTasksByProjectType: typeof newTasksByProject,
      isArray: Array.isArray(newTasksByProject),
      keys: newTasksByProject && typeof newTasksByProject === 'object' ? Object.keys(newTasksByProject) : 'N/A'
    });

    // Marcar como actualizando
    isUpdatingTasksByProjectRef.current = true;

    // Validar datos antes de guardar
    if (!newTasksByProject || typeof newTasksByProject !== 'object' || Array.isArray(newTasksByProject)) {
      console.error('‚ùå safeSetTasksByProject - DATOS INV√ÅLIDOS:', {
        type: typeof newTasksByProject,
        isArray: Array.isArray(newTasksByProject),
        value: newTasksByProject
      });
      isUpdatingTasksByProjectRef.current = false;
      return;
    }

    // Detectar duplicados antes de guardar
    let totalTasks = 0;
    let totalDuplicates = 0;
    Object.entries(newTasksByProject).forEach(([projectId, tasks]) => {
      if (Array.isArray(tasks)) {
        totalTasks += tasks.length;
        
        // Detectar duplicados por ID
        const taskIds = new Set();
        tasks.forEach(task => {
          if (taskIds.has(task.id)) {
            totalDuplicates++;
          } else {
            taskIds.add(task.id);
          }
        });
      }
    });

    if (totalDuplicates > 0) {
      console.warn(`‚ö†Ô∏è safeSetTasksByProject - DUPLICADOS DETECTADOS: ${totalDuplicates} de ${totalTasks} tareas`);
    }

    // Aplicar ordenamiento por wbsCode a todas las tareas de todos los proyectos
    const sortedTasksByProject = {};
    for (const [projectId, tasks] of Object.entries(newTasksByProject)) {
      if (Array.isArray(tasks) && tasks.length > 0) {
        sortedTasksByProject[projectId] = sortTasksByWbsCode(tasks);
        console.log(`üìä Proyecto ${projectId}: ${tasks.length} tareas ordenadas por wbsCode`);
      } else {
        sortedTasksByProject[projectId] = tasks;
      }
    }

    setTasksByProject(sortedTasksByProject);

    // Liberar flag despu√©s de un delay
    setTimeout(() => {
      isUpdatingTasksByProjectRef.current = false;
      console.log('üìä safeSetTasksByProject - FLAG LIBERADO');
    }, 100);
  }, []);

  // Funci√≥n para actualizar tareas del proyecto actual
  const updateCurrentProjectTasks = (newTasks, bypassProtection = false) => {
    // PREVENIR ACTUALIZACIONES SIMULT√ÅNEAS (excepto para importaci√≥n)
    if (!bypassProtection && isUpdatingTasksRef.current) {
      console.warn('‚ö†Ô∏è updateCurrentProjectTasks - ACTUALIZACI√ìN EN PROGRESO, OMITIENDO');
      return;
    }

    console.log('üìä updateCurrentProjectTasks - INICIANDO:', {
      currentProjectId,
      newTasksLength: newTasks?.length,
      newTasksType: typeof newTasks
    });
    
    // Validar que newTasks sea un array v√°lido
    if (!Array.isArray(newTasks)) {
      console.error('‚ùå updateCurrentProjectTasks - newTasks NO ES UN ARRAY:', {
        currentProjectId,
        newTasksType: typeof newTasks,
        newTasksValue: newTasks
      });
      return; // No actualizar si no es un array v√°lido
    }

    // Marcar como actualizando
    isUpdatingTasksRef.current = true;
    
    // Funci√≥n para generar UUID v√°lido
    const generateUUID = () => {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    };
    
    // Validar y corregir IDs de tareas con detecci√≥n robusta de duplicados
    const taskIds = new Set();
    const taskContentHashes = new Set();
    const uniqueTasks = [];
    let duplicatesFound = 0;
    let invalidIdsFixed = 0;
    
    // CORRECCI√ìN: Crear mapeo de IDs originales a nuevos UUIDs para preservar orden
    const idMapping = new Map();
    
    for (const task of newTasks) {
      // Verificar si el ID es un UUID v√°lido
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      let taskId = task.id;
      const originalId = task.id;
      
      if (!uuidRegex.test(taskId)) {
        console.warn(`‚ö†Ô∏è ID inv√°lido detectado: ${taskId} - ${task.name}, generando nuevo UUID`);
        taskId = generateUUID();
        invalidIdsFixed++;
        
        // Guardar mapeo para actualizar referencias
        idMapping.set(originalId, taskId);
      }
      
      // Crear hash de contenido m√°s robusto para detectar duplicados
      const contentHash = JSON.stringify({
        name: task.name,
        duration: task.duration,
        startDate: task.startDate,
        endDate: task.endDate,
        description: task.description,
        predecessors: task.predecessors,
        successors: task.successors
      });
      
      const isDuplicateById = taskIds.has(taskId);
      const isDuplicateByContent = taskContentHashes.has(contentHash);
      
      if (isDuplicateById || isDuplicateByContent) {
        console.warn(`‚ö†Ô∏è Tarea duplicada detectada: ${taskId} - ${task.name} (por ${isDuplicateById ? 'ID' : 'contenido'})`);
        duplicatesFound++;
        continue; // Saltar esta tarea duplicada
      }
      
      // Agregar a conjuntos de control
      taskIds.add(taskId);
      taskContentHashes.add(contentHash);
      
      // CORRECCI√ìN: Actualizar referencias de predecessors y successors con nuevos IDs
      const updatedPredecessors = (task.predecessors || []).map(predId => 
        idMapping.get(predId) || predId
      );
      const updatedSuccessors = (task.successors || []).map(succId => 
        idMapping.get(succId) || succId
      );
      
      // Crear objeto limpio de la tarea
      const cleanTask = {
        id: taskId,
        name: task.name,
        description: task.description,
        duration: task.duration,
        startDate: task.startDate,
        endDate: task.endDate,
        progress: task.progress || 0,
        priority: task.priority,
        cost: task.cost || 0,
        predecessors: updatedPredecessors,
        successors: updatedSuccessors,
        resources: task.resources || [],
        status: task.status || 'pending',
        wbsCode: task.wbsCode,
        assignedTo: task.assignedTo,
        isMilestone: task.isMilestone || false,
        originalDuration: task.originalDuration
      };
      
      // Remover campos undefined/null
      Object.keys(cleanTask).forEach(key => {
        if (cleanTask[key] === undefined || cleanTask[key] === null) {
          delete cleanTask[key];
        }
      });
      
      uniqueTasks.push(cleanTask);
    }
    
    if (duplicatesFound > 0) {
      console.warn(`‚ö†Ô∏è Se encontraron ${duplicatesFound} tareas duplicadas, eliminando duplicados...`);
    }
    
    if (invalidIdsFixed > 0) {
      console.warn(`üîß Se corrigieron ${invalidIdsFixed} IDs inv√°lidos con UUIDs v√°lidos`);
      console.log('üîç Mapeo de IDs actualizado:', Array.from(idMapping.entries()));
    }
    
    // Solo loggear si hay un problema potencial
    if (uniqueTasks.length === 0) {
      console.warn('‚ö†Ô∏è updateCurrentProjectTasks - TAREAS VAC√çAS:', {
        currentProjectId,
        newTasksLength: uniqueTasks.length
      });
    }
    
    setTasksByProject(prev => {
      console.log('üìä updateCurrentProjectTasks - setTasksByProject INICIANDO:', {
        currentProjectId,
        prevKeys: Object.keys(prev || {}),
        newTasksLength: uniqueTasks.length,
        duplicatesRemoved: duplicatesFound
      });
      
      // Verificar que prev sea un objeto v√°lido
      if (!prev || typeof prev !== 'object' || Array.isArray(prev)) {
        console.error('‚ùå updateCurrentProjectTasks - prev NO ES UN OBJETO V√ÅLIDO:', {
          prevType: typeof prev,
          prevValue: prev
        });
        return prev; // Retornar prev sin cambios si no es v√°lido
      }
      
      const updatedProjects = Object.assign({}, prev);
      
      // Aplicar ordenamiento por wbsCode a las tareas del proyecto actual
      const sortedTasks = sortTasksByWbsCode(uniqueTasks);
      updatedProjects[currentProjectId] = sortedTasks;
      
      console.log('üìä updateCurrentProjectTasks - setTasksByProject COMPLETADO:', {
        currentProjectId,
        updatedKeys: Object.keys(updatedProjects),
        tasksInProject: updatedProjects[currentProjectId]?.length,
        duplicatesRemoved: duplicatesFound,
        sortedByWbsCode: true
      });
      
      // Auto-guardar cambios con debouncing
      debouncedSave({
        projects,
        tasksByProject: updatedProjects,
        risksByProject,
        purchaseOrdersByProject,
        advancesByProject,
        invoicesByProject,
        contractsByProject,
        resourceAssignmentsByProject,
        globalResources,
        auditLogsByProject,
        minutasByProject,
        includeWeekendsByProject
      });
      
      return updatedProjects;
    });

    // Liberar flag de actualizaci√≥n despu√©s de un breve delay
    setTimeout(() => {
      isUpdatingTasksRef.current = false;
      console.log('üìä updateCurrentProjectTasks - FLAG LIBERADO');
    }, 100);
  };

  // Funci√≥n especial para importaci√≥n que bypassa la protecci√≥n
  const importTasksToCurrentProject = (newTasks) => {
    console.log('üìä importTasksToCurrentProject - REEMPLAZO COMPLETO DE CRONOGRAMA:', {
      currentProjectId,
      currentTasksCount: getCurrentProjectTasks()?.length || 0,
      newTasksLength: newTasks?.length
    });
    
    // IMPORTANTE: Esta funci√≥n REEMPLAZA COMPLETAMENTE el cronograma anterior
    // No mezcla tareas, las reemplaza por completo
    console.log('üîÑ REEMPLAZANDO CRONOGRAMA COMPLETO - Tareas anteriores ser√°n eliminadas');
    
    // Forzar bypass de protecci√≥n para importaci√≥n
    updateCurrentProjectTasks(newTasks, true);
    
    console.log('‚úÖ CRONOGRAMA REEMPLAZADO EXITOSAMENTE');
  };

  // Funci√≥n para limpiar duplicados en Supabase
  const cleanDuplicatesInSupabase = async () => {
    if (useSupabase && supabaseService.isAuthenticated()) {
      console.log('üßπ Iniciando limpieza de duplicados en Supabase...');
      const success = await supabaseService.cleanDuplicatesInSupabase();
      if (success) {
        alert('‚úÖ Duplicados limpiados exitosamente en Supabase');
        // Recargar datos despu√©s de limpiar
        window.location.reload();
      } else {
        alert('‚ùå Error limpiando duplicados en Supabase');
      }
    } else {
      alert('‚ö†Ô∏è No hay conexi√≥n a Supabase');
    }
  };

  // Funci√≥n para limpiar tareas duplicadas del proyecto actual - CON MONITOREO INTELIGENTE
  const cleanDuplicateTasks = () => {
    const currentTasks = getCurrentProjectTasks();
    if (!Array.isArray(currentTasks) || currentTasks.length === 0) {
      console.log('‚úÖ No hay tareas para verificar duplicados');
      return;
    }

    console.log(`üîç Verificando duplicados en proyecto ${currentProjectId}...`);
    console.log(`üìä Total de tareas: ${currentTasks.length}`);

    // Detectar duplicados REALES (mismo ID)
    const taskIds = new Set();
    const duplicateIds = [];
    const duplicateDetails = [];

    for (const task of currentTasks) {
      if (taskIds.has(task.id)) {
        duplicateIds.push(task.id);
        duplicateDetails.push(`ID: ${task.id}, Nombre: ${task.name}`);
        console.warn(`üö® DUPLICADO REAL detectado: ${task.id} - ${task.name}`);
      } else {
        taskIds.add(task.id);
      }
    }

    if (duplicateIds.length > 0) {
      console.warn(`üö® DUPLICADOS REALES detectados: ${duplicateIds.length}`);
      console.warn('üìã Detalles:', duplicateDetails);
      
      // Crear backup antes de limpiar
      const backup = JSON.stringify(currentTasks);
      localStorage.setItem(`duplicates-backup-${currentProjectId}-${Date.now()}`, backup);
      console.log('üíæ Backup de tareas duplicadas creado');
      
      // Limpiar solo duplicados reales (mantener la primera ocurrencia)
      const uniqueTasks = [];
      const seenIds = new Set();
      
      for (const task of currentTasks) {
        if (!seenIds.has(task.id)) {
          uniqueTasks.push(task);
          seenIds.add(task.id);
        }
      }
      
      console.log(`üßπ Limpiados ${duplicateIds.length} duplicados reales`);
      updateCurrentProjectTasks(uniqueTasks);
    } else {
      console.log('‚úÖ Sin duplicados reales detectados');
    }
  };

  // Funci√≥n para obtener configuraci√≥n de d√≠as laborables del proyecto actual
  const getCurrentProjectIncludeWeekends = () => {
    return includeWeekendsByProject[currentProjectId] || false;
  };

  // Funci√≥n para actualizar configuraci√≥n de d√≠as laborables del proyecto actual
  const updateCurrentProjectIncludeWeekends = (includeWeekends) => {
    setIncludeWeekendsByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = includeWeekends;
      return updatedProjects;
    });
  };

  // Riesgos por proyecto - cada proyecto tiene su propia gesti√≥n de riesgos
  const [risksByProject, setRisksByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin riesgos iniciales
  });

  // Minutas por proyecto - cada proyecto tiene sus propias minutas y tareas
  const [minutasByProject, setMinutasByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin minutas iniciales
  });

  // Funci√≥n para obtener riesgos del proyecto actual
  const getCurrentProjectRisks = () => {
    return risksByProject[currentProjectId] || [];
  };

  // Funci√≥n para obtener minutas del proyecto actual
  const getCurrentProjectMinutas = () => {
    return minutasByProject[currentProjectId] || [];
  };

  // Funci√≥n para actualizar minutas de un proyecto espec√≠fico
  const updateProjectMinutas = (projectId, newMinutas) => {
    setMinutasByProject(prev => ({
      ...prev,
      [projectId]: newMinutas
    }));
  };

  // Funci√≥n para actualizar riesgos del proyecto actual
  const updateCurrentProjectRisks = (newRisksOrUpdater) => {
    // Si es una funci√≥n (setter de React), ejecutarla para obtener el array
    if (typeof newRisksOrUpdater === 'function') {
      const currentRisks = getCurrentProjectRisks();
      const newRisks = newRisksOrUpdater(currentRisks);
      setRisksByProject(prev => {
        const updatedProjects = Object.assign({}, prev);
        updatedProjects[currentProjectId] = newRisks;
        return updatedProjects;
      });
    } else {
      // Si es directamente un array, pasarlo
      setRisksByProject(prev => {
        const updatedProjects = Object.assign({}, prev);
        updatedProjects[currentProjectId] = newRisksOrUpdater;
        return updatedProjects;
      });
    }
  };

  // Funci√≥n para actualizar √≥rdenes de compra del proyecto actual
  const updateCurrentProjectPurchaseOrders = (newPurchaseOrders) => {
    // Validar que newPurchaseOrders sea un array v√°lido
    const safePurchaseOrders = Array.isArray(newPurchaseOrders) ? newPurchaseOrders : [];
    
    console.log('üíæ ACTUALIZANDO √ìRDENES DE COMPRA:', {
      currentProjectId,
      newPurchaseOrdersType: typeof newPurchaseOrders,
      newPurchaseOrdersIsArray: Array.isArray(newPurchaseOrders),
      newPurchaseOrdersLength: safePurchaseOrders.length,
      newPurchaseOrders: safePurchaseOrders
    });
    
    setPurchaseOrdersByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safePurchaseOrders;
      return updatedProjects;
    });
  };

  // Funci√≥n para actualizar anticipos del proyecto actual
  const updateCurrentProjectAdvances = (newAdvances) => {
    const safeAdvances = Array.isArray(newAdvances) ? newAdvances : [];
    console.log('üíæ ACTUALIZANDO ANTICIPOS:', {
      currentProjectId,
      newAdvancesType: typeof newAdvances,
      newAdvancesIsArray: Array.isArray(newAdvances),
      newAdvancesLength: safeAdvances.length
    });
    setAdvancesByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safeAdvances;
      return updatedProjects;
    });
  };

  // Funci√≥n para actualizar facturas del proyecto actual
  const updateCurrentProjectInvoices = (newInvoices) => {
    const safeInvoices = Array.isArray(newInvoices) ? newInvoices : [];
    console.log('üíæ ACTUALIZANDO FACTURAS:', {
      currentProjectId,
      newInvoicesType: typeof newInvoices,
      newInvoicesIsArray: Array.isArray(newInvoices),
      newInvoicesLength: safeInvoices.length
    });
    setInvoicesByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safeInvoices;
      return updatedProjects;
    });
  };

  // Funci√≥n para actualizar contratos del proyecto actual
  const updateCurrentProjectContracts = (newContracts) => {
    const safeContracts = Array.isArray(newContracts) ? newContracts : [];
    console.log('üíæ ACTUALIZANDO CONTRATOS:', {
      currentProjectId,
      newContractsType: typeof newContracts,
      newContractsIsArray: Array.isArray(newContracts),
      newContractsLength: safeContracts.length
    });
    setContractsByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safeContracts;
      return updatedProjects;
    });
  };

  // ===== FUNCIONES DE GESTI√ìN FINANCIERA =====
  
  const [purchaseOrdersByProject, setPurchaseOrdersByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin √≥rdenes iniciales
  });
  

  const [advancesByProject, setAdvancesByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin anticipos iniciales
  });

  const [invoicesByProject, setInvoicesByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin facturas iniciales
  });

  const [contractsByProject, setContractsByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin contratos iniciales
  });

  const getCurrentProjectPurchaseOrders = () => {
    return purchaseOrdersByProject[currentProjectId] || [];
  };

  const getCurrentProjectAdvances = () => {
    return advancesByProject[currentProjectId] || [];
  };

  const getCurrentProjectInvoices = () => {
    return invoicesByProject[currentProjectId] || [];
  };

  const getCurrentProjectContracts = () => {
    return contractsByProject[currentProjectId] || [];
  };

  // ===== FUNCIONES DE GESTI√ìN DE RECURSOS =====
  
  const [globalResources, setGlobalResources] = useState([]);
  const [resourceAssignmentsByProject, setResourceAssignmentsByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin asignaciones iniciales
  });

  const getCurrentProjectResourceAssignments = () => {
    return resourceAssignmentsByProject[currentProjectId] || [];
  };

  // ===== FUNCIONES DE AUDITOR√çA =====
  
  const [auditLogsByProject, setAuditLogsByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin logs iniciales
  });
  const [dataLoaded, setDataLoaded] = useState(false);

  const getCurrentProjectAuditLogs = () => {
    return auditLogsByProject[currentProjectId] || [];
  };

  // ===== SISTEMA DE PERSISTENCIA =====
  
  // Funci√≥n para guardar y cerrar
  // Funciones de autenticaci√≥n
  const handleAuthSuccess = async (user) => {
    console.log('‚úÖ Usuario autenticado:', user);
    setUseSupabase(true);
    setShowAuthModal(false);
    
    // Recargar datos desde Supabase
    const savedData = await supabaseService.loadPortfolioData();
    if (savedData) {
      if (savedData.projects && Array.isArray(savedData.projects) && savedData.projects.length > 0) {
        setProjects(savedData.projects);
      }
      if (savedData.currentProjectId) {
        setCurrentProjectId(savedData.currentProjectId);
      }
      if (savedData.tasksByProject) {
        safeSetTasksByProject(savedData.tasksByProject);
      }
      if (savedData.risksByProject) {
        setRisksByProject(savedData.risksByProject);
      }
      if (savedData.globalResources) {
        setGlobalResources(savedData.globalResources);
      }
    }
  };

  const handleAuthCancel = () => {
    console.log('‚ùå Usuario cancel√≥ autenticaci√≥n, usando modo local');
    setShowAuthModal(false);
    setUseSupabase(false);
  };

  const handleSaveAndClose = async () => {
    try {
      console.log('üíæ Guardando datos antes de cerrar...');
      
      // Crear objeto con todos los datos actuales
      const dataToSave = {
        projects,
        currentProjectId,
        tasksByProject,
        includeWeekendsByProject,
        risksByProject,
        purchaseOrdersByProject,
        advancesByProject,
        invoicesByProject,
        contractsByProject,
        globalResources,
        resourceAssignmentsByProject,
        auditLogsByProject,
        timestamp: new Date().toISOString()
      };

      // Guardar usando Supabase si est√° disponible, sino usar localStorage
      if (useSupabase && supabaseService.isAuthenticated()) {
        console.log('üíæ Guardando en Supabase...');
        const success = await supabaseService.savePortfolioData(dataToSave);
        if (success) {
          console.log('‚úÖ Datos guardados exitosamente en Supabase');
          alert('‚úÖ Datos guardados exitosamente en la nube. Puedes cerrar la aplicaci√≥n manualmente.');
        } else {
          throw new Error('Error guardando en Supabase');
        }
      } else {
        console.log('üíæ Guardando en localStorage...');
        await filePersistenceService.saveData(dataToSave);
        console.log('‚úÖ Datos guardados exitosamente en localStorage');
        alert('‚úÖ Datos guardados exitosamente en archivo local. Puedes cerrar la aplicaci√≥n manualmente.');
      }
      
    } catch (error) {
      console.error('‚ùå Error guardando datos:', error);
      alert('‚ùå Error al guardar los datos. Por favor, int√©ntalo de nuevo.');
    }
  };
  
  // Cargar datos del localStorage o Supabase al iniciar
  useEffect(() => {
    const loadData = async () => {
      try {
        console.log('üöÄ Iniciando carga de datos...');
        
        // Inicializar Supabase primero
        console.log('üîß Inicializando Supabase...');
        const supabaseReady = await supabaseService.initialize();
        setSupabaseInitialized(supabaseReady);
        
        if (supabaseReady) {
          if (supabaseService.getCurrentUser()) {
            console.log('‚úÖ Supabase inicializado con usuario autenticado');
            setUseSupabase(true);
            
            // Cargar datos desde Supabase
            console.log('üîç Cargando datos desde Supabase...');
            const savedData = await supabaseService.loadPortfolioData();
            console.log('üîç Resultado de loadPortfolioData():', savedData);
            
            if (!savedData || !savedData.organization) {
              console.warn('‚ö†Ô∏è No se pudieron cargar datos desde Supabase');
              console.warn('‚ö†Ô∏è Continuando con datos locales...');
              // Usar fallback a IndexedDB/localStorage
              setUseSupabase(false);
            } else {
              console.log('üìÇ Datos encontrados en Supabase, cargando...');
              
              // Usar datos de Supabase
              if (savedData.organization) {
                console.log('‚úÖ Datos sincronizados desde Supabase');
              }
              if (savedData.projects && Array.isArray(savedData.projects) && savedData.projects.length > 0) {
                console.log('üìÇ Cargando proyectos desde Supabase:', savedData.projects.length);
                setProjects(savedData.projects);
              }
              if (savedData.currentProjectId) {
                setCurrentProjectId(savedData.currentProjectId);
              }
              if (savedData.tasksByProject) {
                safeSetTasksByProject(savedData.tasksByProject);
              }
              if (savedData.minutasByProject) {
                setMinutasByProject(savedData.minutasByProject);
              }
              if (savedData.risksByProject) {
                setRisksByProject(savedData.risksByProject);
              }
              if (savedData.purchaseOrdersByProject) {
                setPurchaseOrdersByProject(savedData.purchaseOrdersByProject);
              }
              if (savedData.advancesByProject) {
                setAdvancesByProject(savedData.advancesByProject);
              }
              if (savedData.invoicesByProject) {
                setInvoicesByProject(savedData.invoicesByProject);
              }
              if (savedData.contractsByProject) {
                setContractsByProject(savedData.contractsByProject);
              }
              if (savedData.globalResources) {
                setGlobalResources(savedData.globalResources);
              }
              setDataLoaded(true);
              return;
            }
        } else {
          console.log('‚ö†Ô∏è Supabase disponible pero sin usuario autenticado');
          // Mostrar modal de autenticaci√≥n inmediatamente
          setShowAuthModal(true);
        }
        }
        
        // Fallback: usar localStorage si Supabase no est√° disponible
        console.log('‚ö†Ô∏è Supabase no disponible, usando localStorage...');
        setUseSupabase(false);
        
        // Inicializar servicio de persistencia local
        console.log('üîß Inicializando filePersistenceService...');
        await filePersistenceService.initialize();
        console.log('‚úÖ filePersistenceService inicializado');
        
        // Cargar datos desde el servicio local
        console.log('üîç Llamando a filePersistenceService.loadData()...');
        const savedData = await filePersistenceService.loadData();
        console.log('üîç Resultado de loadData():', savedData);
        
        if (savedData) {
          console.log('üìÇ Datos encontrados, cargando...');
          console.log('üìÇ globalResources en datos guardados:', savedData.globalResources);
          
          if (savedData.projects && Array.isArray(savedData.projects) && savedData.projects.length > 0) {
            console.log('üìÇ Cargando proyectos guardados:', savedData.projects.length);
            setProjects(savedData.projects);
          } else {
            console.log('üìÇ No hay proyectos guardados v√°lidos, manteniendo proyectos iniciales');
          }
          if (savedData.currentProjectId) {
            setCurrentProjectId(savedData.currentProjectId);
          }
          if (savedData.tasksByProject) {
            safeSetTasksByProject(savedData.tasksByProject);
          }
          if (savedData.minutasByProject) {
            setMinutasByProject(savedData.minutasByProject);
          }
          if (savedData.includeWeekendsByProject) {
            setIncludeWeekendsByProject(savedData.includeWeekendsByProject);
          }
          if (savedData.risksByProject) {
            setRisksByProject(savedData.risksByProject);
          }
          if (savedData.purchaseOrdersByProject) {
            setPurchaseOrdersByProject(savedData.purchaseOrdersByProject);
          }
          if (savedData.advancesByProject) {
            setAdvancesByProject(savedData.advancesByProject);
          }
          if (savedData.invoicesByProject) {
            setInvoicesByProject(savedData.invoicesByProject);
          }
          if (savedData.contractsByProject) {
            setContractsByProject(savedData.contractsByProject);
          }
          if (savedData.globalResources) {
            console.log('üìÇ Estableciendo globalResources:', savedData.globalResources);
            setGlobalResources(savedData.globalResources);
          }
          if (savedData.resourceAssignmentsByProject) {
            setResourceAssignmentsByProject(savedData.resourceAssignmentsByProject);
          }
          if (savedData.auditLogsByProject) {
            setAuditLogsByProject(savedData.auditLogsByProject);
          }
        } else {
          console.log('üìÇ No se encontraron datos guardados');
          console.log('üìÇ savedData es:', savedData);
        }
        
        // Limpiar datos corruptos una sola vez despu√©s de cargar
        cleanCorruptDataOnce();
        
        // Marcar que los datos iniciales se han cargado
        console.log('‚úÖ Marcando dataLoaded como true');
        setDataLoaded(true);
      } catch (error) {
        console.error('‚ùå Error al cargar datos:', error);
        console.error('‚ùå Stack trace:', error.stack);
        // Marcar como cargado incluso si hay error para evitar bloqueo
        setDataLoaded(true);
      }
    };

    loadData();
  }, []);

  // SOLUCI√ìN PERMANENTE: Recargar datos desde Supabase cuando cambie el proyecto actual
  useEffect(() => {
    if (!dataLoaded || !useSupabase || !supabaseService.isAuthenticated()) {
      return;
    }

    const reloadProjectData = async () => {
      try {
        console.log('üîÑ Recargando datos para el proyecto actual:', currentProjectId);
        const savedData = await supabaseService.loadPortfolioData();
        
        if (savedData) {
          // Actualizar solo los datos espec√≠ficos del proyecto actual
          if (savedData.purchaseOrdersByProject) {
            setPurchaseOrdersByProject(savedData.purchaseOrdersByProject);
          }
          if (savedData.risksByProject) {
            setRisksByProject(savedData.risksByProject);
          }
          if (savedData.tasksByProject) {
            safeSetTasksByProject(savedData.tasksByProject);
          }
          if (savedData.advancesByProject) {
            setAdvancesByProject(savedData.advancesByProject);
          }
          if (savedData.invoicesByProject) {
            setInvoicesByProject(savedData.invoicesByProject);
          }
          if (savedData.contractsByProject) {
            setContractsByProject(savedData.contractsByProject);
          }
        }
      } catch (error) {
        console.error('‚ùå Error recargando datos del proyecto:', error);
      }
    };

    reloadProjectData();
  }, [currentProjectId, dataLoaded, useSupabase]);

  // Escuchar eventos de restauraci√≥n e importaci√≥n
  useEffect(() => {
    const handleDataRestore = (event) => {
      const { data } = event.detail;
      
      if (data.projects) setProjects(data.projects);
      if (data.currentProjectId) setCurrentProjectId(data.currentProjectId);
      if (data.tasksByProject) safeSetTasksByProject(data.tasksByProject);
      if (data.risksByProject) setRisksByProject(data.risksByProject);
      if (data.purchaseOrdersByProject) {
        setPurchaseOrdersByProject(data.purchaseOrdersByProject);
      }
      if (data.advancesByProject) setAdvancesByProject(data.advancesByProject);
      if (data.invoicesByProject) setInvoicesByProject(data.invoicesByProject);
      if (data.contractsByProject) setContractsByProject(data.contractsByProject);
      if (data.globalResources) setGlobalResources(data.globalResources);
      if (data.resourceAssignmentsByProject) setResourceAssignmentsByProject(data.resourceAssignmentsByProject);
      if (data.auditLogsByProject) setAuditLogsByProject(data.auditLogsByProject);
    };

    const handleDataImport = (event) => {
      const { data } = event.detail;
      
      if (data.projects) setProjects(data.projects);
      if (data.currentProjectId) setCurrentProjectId(data.currentProjectId);
      if (data.tasksByProject) safeSetTasksByProject(data.tasksByProject);
      if (data.risksByProject) setRisksByProject(data.risksByProject);
      if (data.purchaseOrdersByProject) {
        setPurchaseOrdersByProject(data.purchaseOrdersByProject);
      }
      if (data.advancesByProject) setAdvancesByProject(data.advancesByProject);
      if (data.invoicesByProject) setInvoicesByProject(data.invoicesByProject);
      if (data.contractsByProject) setContractsByProject(data.contractsByProject);
      if (data.globalResources) setGlobalResources(data.globalResources);
      if (data.resourceAssignmentsByProject) setResourceAssignmentsByProject(data.resourceAssignmentsByProject);
      if (data.auditLogsByProject) setAuditLogsByProject(data.auditLogsByProject);
    };

    const handleToggleSupabase = (event) => {
      const { useSupabase: newUseSupabase } = event.detail;
      console.log('üîÑ Toggle Supabase desde ProjectManagementTabs:', newUseSupabase);
      setUseSupabase(newUseSupabase);
    };

    const handleRequestSupabaseAuth = (event) => {
      const { action } = event.detail;
      console.log('üîê Solicitud de autenticaci√≥n Supabase:', action);
      
      if (action === 'activate') {
        // Verificar si ya est√° autenticado
        if (supabaseService.isAuthenticated()) {
          console.log('‚úÖ Ya est√° autenticado, activando Supabase...');
          setUseSupabase(true);
          alert('‚úÖ Supabase activado\n\nLos datos se sincronizar√°n autom√°ticamente con la base de datos en la nube.');
        } else {
          console.log('üîê No est√° autenticado, mostrando modal...');
          setShowAuthModal(true);
        }
      }
    };

    window.addEventListener('dataRestore', handleDataRestore);
    window.addEventListener('dataImport', handleDataImport);
    window.addEventListener('toggleSupabase', handleToggleSupabase);
    window.addEventListener('requestSupabaseAuth', handleRequestSupabaseAuth);

    return () => {
      window.removeEventListener('dataRestore', handleDataRestore);
      window.removeEventListener('dataImport', handleDataImport);
      window.removeEventListener('toggleSupabase', handleToggleSupabase);
      window.removeEventListener('requestSupabaseAuth', handleRequestSupabaseAuth);
    };
  }, []);

  // ===== SISTEMA DE GUARDADO CON THROTTLING =====
  
  // Ref para controlar el throttling y evitar bucles infinitos
  const saveTimeoutRef = useRef(null);
  const lastSaveDataRef = useRef(null);
  const isSavingRef = useRef(false);

  // Funci√≥n para comparar si los datos han cambiado realmente
  const hasDataChanged = (newData, oldData) => {
    if (!oldData) return true;
    
    // Comparar solo los campos esenciales para evitar guardados innecesarios
    const essentialFields = [
      'projects', 'currentProjectId', 'tasksByProject', 'risksByProject',
      'globalResources', 'purchaseOrdersByProject', 'advancesByProject',
      'invoicesByProject', 'contractsByProject', 'resourceAssignmentsByProject',
      'auditLogsByProject'
    ];
    
    return essentialFields.some(field => {
      const newValue = newData[field];
      const oldValue = oldData[field];
      
      // Para tareas, verificar cambios m√°s espec√≠ficos y robustos
      if (field === 'tasksByProject') {
        if (!newValue || !oldValue) return newValue !== oldValue;
        
        // Verificar si el n√∫mero de tareas cambi√≥
        const newTaskCount = Object.values(newValue).reduce((total, tasks) => total + (tasks?.length || 0), 0);
        const oldTaskCount = Object.values(oldValue).reduce((total, tasks) => total + (tasks?.length || 0), 0);
        
        if (newTaskCount !== oldTaskCount) {
          console.log(`üìä Cambio detectado en tareas: ${oldTaskCount} ‚Üí ${newTaskCount}`);
          return true;
        }
        
        // Verificar cambios en tareas espec√≠ficas por proyecto
        for (const projectId in newValue) {
          const newTasks = newValue[projectId] || [];
          const oldTasks = oldValue[projectId] || [];
          
          if (newTasks.length !== oldTasks.length) {
            console.log(`üìä Cambio en n√∫mero de tareas del proyecto ${projectId}: ${oldTasks.length} ‚Üí ${newTasks.length}`);
            return true;
          }
          
          // Crear hashes de contenido para comparaci√≥n m√°s eficiente
          const newTaskHashes = newTasks.map(task => 
            JSON.stringify({
              id: task.id,
              name: task.name,
              duration: task.duration,
              startDate: task.startDate,
              endDate: task.endDate,
              progress: task.progress,
              status: task.status,
              predecessors: task.predecessors,
              successors: task.successors
            })
          ).sort();
          
          const oldTaskHashes = oldTasks.map(task => 
            JSON.stringify({
              id: task.id,
              name: task.name,
              duration: task.duration,
              startDate: task.startDate,
              endDate: task.endDate,
              progress: task.progress,
              status: task.status,
              predecessors: task.predecessors,
              successors: task.successors
            })
          ).sort();
          
          // Comparar hashes ordenados
          if (JSON.stringify(newTaskHashes) !== JSON.stringify(oldTaskHashes)) {
            console.log(`üìä Cambio detectado en contenido de tareas del proyecto ${projectId}`);
            return true;
          }
        }
        return false;
      }
      
      if (field === 'projects' || field === 'risksByProject' || 
          field === 'globalResources' || field === 'purchaseOrdersByProject' || 
          field === 'advancesByProject' || field === 'invoicesByProject' || 
          field === 'contractsByProject' || field === 'resourceAssignmentsByProject' || 
          field === 'auditLogsByProject' || field === 'minutasByProject') {
        return JSON.stringify(newValue) !== JSON.stringify(oldValue);
      }
      
      return newValue !== oldValue;
    });
  };

  // Funci√≥n de guardado con throttling
  const throttledSave = useCallback((dataToSave) => {
    // Cancelar guardado anterior si existe
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    // Verificar si los datos han cambiado realmente
    if (!hasDataChanged(dataToSave, lastSaveDataRef.current)) {
      console.log('‚è≠Ô∏è Datos sin cambios, omitiendo guardado');
      return;
    }

    // Verificar que no est√© guardando ya
    if (isSavingRef.current) {
      console.log('‚è≥ Ya hay un guardado en progreso, omitiendo');
      return;
    }

    // PROTECCI√ìN INTELIGENTE: Verificar duplicaci√≥n masiva vs. proyectos grandes leg√≠timos
    const tasksByProject = dataToSave.tasksByProject || {};
    const totalTasks = Object.values(tasksByProject).reduce((total, tasks) => total + (tasks?.length || 0), 0);
    const projectCount = Object.keys(tasksByProject).length;
    const avgTasksPerProject = projectCount > 0 ? totalTasks / projectCount : 0;
    
    // Detectar duplicaci√≥n masiva: muchas tareas en pocos proyectos (ratio sospechoso)
    const isMassiveDuplication = totalTasks > 1000 && avgTasksPerProject > 800;
    
    if (isMassiveDuplication) {
      console.error(`üö® ALERTA: Posible duplicaci√≥n masiva detectada:`);
      console.error(`  ‚Ä¢ Total tareas: ${totalTasks}`);
      console.error(`  ‚Ä¢ Proyectos: ${projectCount}`);
      console.error(`  ‚Ä¢ Promedio por proyecto: ${avgTasksPerProject.toFixed(1)}`);
      console.error(`  ‚Ä¢ Cancelando guardado por seguridad`);
      return;
    }
    
    // Log informativo para proyectos grandes leg√≠timos
    if (totalTasks > 500) {
      console.log(`üìä Proyecto grande detectado: ${totalTasks} tareas en ${projectCount} proyectos (promedio: ${avgTasksPerProject.toFixed(1)} tareas/proyecto)`);
    }

    // Guardar con throttling de 1 segundo y cola de guardado
    saveTimeoutRef.current = setTimeout(async () => {
      try {
        isSavingRef.current = true;
        
        console.log('üíæ Guardando datos con throttling...');
        
        // Guardar usando Supabase si est√° disponible, sino usar localStorage
        if (useSupabase && supabaseService.isAuthenticated()) {
          console.log('üíæ Guardando en Supabase...');
          const success = await supabaseService.savePortfolioData(dataToSave);
          if (!success) {
            throw new Error('Error guardando en Supabase');
          }
          console.log('‚úÖ Datos guardados en Supabase');
        } else {
          // Fallback: usar localStorage y archivo local
          try {
            localStorage.setItem('mi-dashboard-portfolio', JSON.stringify(dataToSave));
            console.log('‚úÖ Datos guardados en localStorage');
          } catch (error) {
            console.error('‚ùå Error guardando en localStorage:', error);
            // Si localStorage falla, intentar limpiar datos antiguos
            if (error.name === 'QuotaExceededError') {
              console.log('üßπ Espacio insuficiente, limpiando datos antiguos...');
              // Aqu√≠ podr√≠as implementar limpieza de datos antiguos
            }
            throw error;
          }
          
          // Guardar en archivo local (persistente) con reintentos
          let retries = 3;
          while (retries > 0) {
            try {
              await filePersistenceService.saveData(dataToSave);
              break;
            } catch (error) {
              retries--;
              if (retries === 0) throw error;
              console.log(`üîÑ Reintentando guardado... (${retries} intentos restantes)`);
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
        }
        
        // Actualizar referencia de √∫ltimo guardado
        lastSaveDataRef.current = dataToSave;
        
        console.log('‚úÖ Datos guardados exitosamente');
        
        // Disparar evento de sincronizaci√≥n SOLO si es necesario
        // y no estamos en el proceso de carga inicial
        if (dataLoaded) {
          const syncEvent = new CustomEvent('dataSync', { 
            detail: { 
              type: 'portfolio_data_saved', 
              timestamp: new Date().toISOString(),
              source: 'throttled_save'
            } 
          });
          window.dispatchEvent(syncEvent);
        }
        
      } catch (error) {
        console.error('‚ùå Error guardando datos:', error);
      } finally {
        isSavingRef.current = false;
      }
    }, 1000); // Throttling de 1 segundo
  }, [dataLoaded]);

  // Guardar datos cuando cambien (solo despu√©s de cargar datos iniciales)
  useEffect(() => {
    // No guardar hasta que se hayan cargado los datos iniciales
    if (!dataLoaded) {
      console.log('‚è≥ Esperando a que se carguen los datos iniciales...');
      return;
    }

    console.log('üîÑ useEffect GUARDADO - EJECUT√ÅNDOSE:', {
      tasksByProjectKeys: Object.keys(tasksByProject),
      tasksForCurrentProject: tasksByProject[currentProjectId] ? tasksByProject[currentProjectId].length : 'UNDEFINED',
      currentProjectId,
      totalTasks: Object.values(tasksByProject).reduce((total, tasks) => total + (tasks?.length || 0), 0)
    });

    const dataToSave = {
      projects,
      currentProjectId,
      tasksByProject,
      minutasByProject,
      includeWeekendsByProject,
      risksByProject,
      purchaseOrdersByProject,
      advancesByProject,
      invoicesByProject,
      contractsByProject,
      globalResources,
      resourceAssignmentsByProject,
      auditLogsByProject,
      timestamp: new Date().toISOString()
    };

    // Usar funci√≥n de guardado con throttling
    throttledSave(dataToSave);
  }, [projects, currentProjectId, tasksByProject, minutasByProject, includeWeekendsByProject, risksByProject, purchaseOrdersByProject, advancesByProject, invoicesByProject, contractsByProject, globalResources, resourceAssignmentsByProject, auditLogsByProject, dataLoaded]); // INCLUIDO tasksByProject y minutasByProject en las dependencias para guardado autom√°tico

  // Limpiar timeout al desmontar el componente
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, []);

  // Actualizar progreso autom√°tico de proyectos cuando cambien las tareas
  useEffect(() => {
    if (!dataLoaded || !tasksByProject) return;
    
    console.log('üîÑ ACTUALIZANDO PROGRESO AUTOM√ÅTICO DE PROYECTOS');
    
    // Actualizar progreso de todos los proyectos activos
    let hasUpdates = false;
    const updates = [];
    
    projects.forEach(project => {
      if (project.status === 'active') {
        const newProgress = calculateProjectProgress(project.id);
        
        // Solo actualizar si el progreso ha cambiado
        if (newProgress !== project.progress) {
          console.log(`üìä Actualizando progreso del proyecto ${project.name}: ${project.progress}% ‚Üí ${newProgress}%`);
          updates.push({ id: project.id, progress: newProgress });
          hasUpdates = true;
        }
      }
    });
    
    // Aplicar todas las actualizaciones de una vez
    if (hasUpdates) {
      setProjects(prev => prev.map(p => {
        const update = updates.find(u => u.id === p.id);
        return update 
          ? { ...p, progress: update.progress, updatedAt: new Date().toISOString() }
          : p;
      }));
    }
  }, [tasksByProject, dataLoaded]); // Removido 'projects' de las dependencias para evitar bucle infinito

  // ===== FUNCIONES DE GESTI√ìN DE PROYECTOS =====
  
  // Funci√≥n para calcular el progreso autom√°tico del proyecto basado en sus tareas
  const calculateProjectProgress = (projectId) => {
    const projectTasks = tasksByProject[projectId] || [];
    
    if (projectTasks.length === 0) {
      return 0;
    }
    
    // Calcular progreso promedio de todas las tareas (excluyendo hitos)
    const regularTasks = projectTasks.filter(task => !task.isMilestone);
    
    if (regularTasks.length === 0) {
      return 0;
    }
    
    const totalProgress = regularTasks.reduce((sum, task) => sum + (task.progress || 0), 0);
    const averageProgress = Math.round(totalProgress / regularTasks.length);
    
    console.log('üîÑ C√ÅLCULO PROGRESO AUTOM√ÅTICO:', {
      projectId,
      totalTasks: projectTasks.length,
      regularTasks: regularTasks.length,
      totalProgress,
      averageProgress,
      tasksDetails: regularTasks.map(t => ({ 
        name: t.name, 
        progress: t.progress,
        isMilestone: t.isMilestone
      }))
    });
    
    return Math.min(100, Math.max(0, averageProgress));
  };
  
  const createProject = (projectData) => {
    // Generar UUID v√°lido para el proyecto
    const generateUUID = () => {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    };

    const newProject = {
      id: generateUUID(),
      name: projectData.name,
      description: projectData.description,
      startDate: projectData.startDate,
      endDate: projectData.endDate,
      budget: projectData.budget,
      status: projectData.status,
      priority: projectData.priority,
      manager: projectData.manager,
      sponsor: projectData.sponsor || '',
      objective: projectData.objective || '',
      businessCase: projectData.businessCase || '',
      irr: projectData.irr || 0,
      roi: projectData.roi || 0,
      contingencyReserve: projectData.contingencyReserve || 0,
      managementReserve: projectData.managementReserve || 0,
      kickoffDate: projectData.kickoffDate || '',
      stakeholders: projectData.stakeholders || [],
      team: projectData.team || [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: '1.0.0',
      progress: 0
    };
    
    setProjects(prev => {
      const updatedProjects = prev.slice();
      updatedProjects.push(newProject);
      return updatedProjects;
    });
    
    // Work Packages eliminados - ya no se usan
    
    setTasksByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[newProject.id] = [];
      return updatedProjects;
    });
    
    setIncludeWeekendsByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[newProject.id] = false; // Por defecto: solo d√≠as laborales
      return updatedProjects;
    });
    
    setRisksByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[newProject.id] = [];
      return updatedProjects;
    });
    
    return newProject;
  };

  const updateProject = (projectId, updates) => {
    // Calcular progreso autom√°tico si no se proporciona expl√≠citamente
    const autoProgress = updates.progress !== undefined ? updates.progress : calculateProjectProgress(projectId);
    
    setProjects(prev => prev.map(project => 
      project.id === projectId 
        ? { 
            id: project.id,
            name: updates.name || project.name,
            description: updates.description || project.description,
            startDate: updates.startDate || project.startDate,
            endDate: updates.endDate || project.endDate,
            budget: updates.budget || project.budget,
            status: updates.status || project.status,
            priority: updates.priority || project.priority,
            manager: updates.manager || project.manager,
            sponsor: updates.sponsor || project.sponsor,
            irr: updates.irr !== undefined ? updates.irr : project.irr,
            objective: updates.objective || project.objective,
            businessCase: updates.businessCase || project.businessCase,
            team: updates.team || project.team,
            createdAt: project.createdAt,
            updatedAt: new Date().toISOString(),
            version: project.version,
            progress: autoProgress
          }
        : project
    ));
  };

  const deleteProject = async (projectId) => {
    // Eliminar de Supabase si est√° autenticado
    if (useSupabase && supabaseService.isAuthenticated()) {
      console.log(`üóëÔ∏è Eliminando proyecto ${projectId} de Supabase...`);
      const success = await supabaseService.deleteProject(projectId);
      if (success) {
        console.log(`‚úÖ Proyecto ${projectId} eliminado de Supabase`);
      } else {
        console.warn(`‚ö†Ô∏è Error eliminando proyecto ${projectId} de Supabase`);
      }
    }

    // Eliminar localmente
    setProjects(prev => prev.filter(project => project.id !== projectId));
    
    // Work Packages eliminados - ya no se usan
    
    setTasksByProject(prev => {
      const newData = Object.assign({}, prev);
      delete newData[projectId];
      return newData;
    });
    
    setRisksByProject(prev => {
      const newData = Object.assign({}, prev);
      delete newData[projectId];
      return newData;
    });
  };

  // ===== FUNCIONES DE WORK PACKAGES =====
  
  // Work Packages eliminados - ya no se usan

  // ===== M√âTRICAS DEL PORTAFOLIO =====
  
  const portfolioMetrics = useMemo(() => {
    const totalProjects = projects.length;
    const activeProjects = projects.filter(p => p.status === 'active').length;
    const completedProjects = projects.filter(p => p.status === 'completed').length;
    const totalBudget = projects.reduce((sum, p) => sum + (p.budget || 0), 0);
    const totalProgress = projects.reduce((sum, p) => sum + (p.progress || 0), 0);
    const averageProgress = totalProjects > 0 ? totalProgress / totalProjects : 0;
    
    return {
      totalProjects,
      activeProjects,
      completedProjects,
      totalBudget,
      averageProgress,
      healthScore: averageProgress > 80 ? 'excellent' : averageProgress > 60 ? 'good' : 'needs_attention'
    };
  }, [projects]);

  // ===== FUNCIONES DE IMPORTACI√ìN/EXPORTACI√ìN =====
  
  const importData = (data) => {
    try {
      if (data.projects) setProjects(data.projects);
      if (data.currentProjectId) setCurrentProjectId(data.currentProjectId);
      if (data.tasksByProject) safeSetTasksByProject(data.tasksByProject);
      if (data.includeWeekendsByProject) setIncludeWeekendsByProject(data.includeWeekendsByProject);
      if (data.risksByProject) setRisksByProject(data.risksByProject);
      if (data.purchaseOrdersByProject) {
        setPurchaseOrdersByProject(data.purchaseOrdersByProject);
      }
      if (data.advancesByProject) setAdvancesByProject(data.advancesByProject);
      if (data.invoicesByProject) setInvoicesByProject(data.invoicesByProject);
      if (data.contractsByProject) setContractsByProject(data.contractsByProject);
      if (data.globalResources) setGlobalResources(data.globalResources);
      if (data.resourceAssignmentsByProject) setResourceAssignmentsByProject(data.resourceAssignmentsByProject);
      if (data.auditLogsByProject) setAuditLogsByProject(data.auditLogsByProject);
      
      // Disparar evento de sincronizaci√≥n
      const syncEvent = new CustomEvent('dataSync', { 
        detail: { 
          type: 'data_imported', 
          timestamp: new Date().toISOString() 
        } 
      });
      window.dispatchEvent(syncEvent);
      
      return true;
      } catch (error) {
      console.error('Error al importar datos:', error);
      return false;
    }
  };

  // ===== ESTADOS DE INTERFAZ =====
  
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  const [showSchedule, setShowSchedule] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [reportingDate, setReportingDate] = useState(new Date().toISOString().split('T')[0]);
  const [showHelp, setShowHelp] = useState(false);
  // Funci√≥n para determinar la secci√≥n inicial basada en permisos
  const getInitialSection = () => {
    // Usuarios de solo lectura: iniciar en 'executive' (Dashboard Ejecutivo)
    // Usuarios normales: iniciar en 'portfolio' (comportamiento por defecto)
    // La redirecci√≥n autom√°tica se maneja en el useEffect
    return 'portfolio';
  };

  const [activeSection, setActiveSection] = useState('portfolio'); // Se actualizar√° cuando se carguen los permisos
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false); // Iniciar expandido

  // Funci√≥n para cambiar secci√≥n y colapsar sidebar autom√°ticamente
  const handleSectionChange = (sectionId) => {
    setActiveSection(sectionId);
    setIsSidebarCollapsed(true); // Colapsar sidebar autom√°ticamente
  };

  // Redirecci√≥n autom√°tica para usuarios de solo lectura
  useEffect(() => {
    // Solo ejecutar cuando los permisos ya se cargaron
    if (!permissionsLoading && userRole) {
      const currentSection = activeSection;
      const isReadOnlyUser = isReadOnly();
      
      console.log('üîç Verificando redirecci√≥n autom√°tica:', {
        userRole,
        isReadOnlyUser,
        currentSection,
        permissionsLoading
      });
      
      // Solo redirigir usuarios de solo lectura desde secciones restringidas
      if (isReadOnlyUser && (currentSection === 'portfolio' || currentSection === 'user-management')) {
        console.log('üîÑ Redirigiendo usuario de solo lectura de', currentSection, 'a Dashboard Ejecutivo');
        setActiveSection('executive');
      }
      // NOTA: Usuarios con permisos completos tienen navegaci√≥n libre - NO redirigir
    }
  }, [permissionsLoading, userRole, isReadOnly, activeSection]);

  // Estados de modales
  const [showPOModal, setShowPOModal] = useState(false);
  const [showAdvanceModal, setShowAdvanceModal] = useState(false);
  const [showInvoiceModal, setShowInvoiceModal] = useState(false);
  const [editingPO, setEditingPO] = useState(null);
  const [editingAdvance, setEditingAdvance] = useState(null);
  const [editingInvoice, setEditingInvoice] = useState(null);

  // ===== RENDERIZADO =====
  
  const currentProject = projects.find(p => p.id === currentProjectId);

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Modal de autenticaci√≥n */}
      {showAuthModal && (
        <SupabaseAuth
          onAuthSuccess={handleAuthSuccess}
          onAuthCancel={handleAuthCancel}
        />
      )}
      
      <SyncIndicator 
        useSupabase={useSupabase}
        supabaseInitialized={supabaseInitialized}
        isAuthenticated={supabaseService.isAuthenticated()}
      />
      
      {/* Bot√≥n para mostrar modal de Supabase */}
      {!useSupabase && supabaseInitialized && (
        <div className="fixed top-20 right-4 z-40">
          <button
            onClick={() => setShowAuthModal(true)}
            className="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg hover:bg-blue-700 transition-colors"
          >
            ‚òÅÔ∏è Conectar con la Nube
          </button>
        </div>
      )}
      <FileStatusIndicator />
      <AutoSaveIndicator />
      <BackupManager onRestoreData={importData} />
      
      <div className="flex">
        <Sidebar 
          activeSection={activeSection}
          onSectionChange={handleSectionChange}
          projects={projects}
          currentProjectId={currentProjectId}
          workPackages={[]}
          risks={getCurrentProjectRisks()}
          isCollapsed={isSidebarCollapsed}
          onToggleCollapse={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
        />
        
        <main className={`flex-1 transition-all duration-300 ${isSidebarCollapsed ? 'ml-16' : 'ml-80 lg:ml-72'}`}>
          <div className={`transition-all duration-300 ${isSidebarCollapsed ? 'p-4' : 'p-6'}`}>
            {/* Dashboard Ejecutivo */}
            {activeSection === 'executive' && (
              <ConsolidatedDashboard 
                projects={projects}
                portfolioMetrics={portfolioMetrics}
                workPackages={[]}
                risks={Object.values(risksByProject).flat()}
                purchaseOrders={Object.values(purchaseOrdersByProject).flat()}
                advances={Object.values(advancesByProject).flat()}
                invoices={Object.values(invoicesByProject).flat()}
                tasksByProject={tasksByProject}
                purchaseOrdersByProject={purchaseOrdersByProject}
                advancesByProject={advancesByProject}
                invoicesByProject={invoicesByProject}
              />
            )}

            {/* Gesti√≥n de Usuarios */}
            {activeSection === 'user-management' && (
              <UserManagement
                currentProject={currentProject}
                useSupabase={useSupabase}
                projects={projects}
              />
            )}

            {/* Portafolio de Proyectos */}
        {activeSection === 'portfolio' && (
          <PortfolioStrategic
            projects={projects}
            currentProjectId={currentProjectId}
            setCurrentProjectId={setCurrentProjectId}
                workPackages={[]}
                risks={getCurrentProjectRisks()}
                globalResources={globalResources}
                setGlobalResources={setGlobalResources}
            createProject={createProject}
            updateProject={updateProject}
            deleteProject={deleteProject}
                tasks={getCurrentProjectTasks()}
                tasksByProject={tasksByProject}
                minutasByProject={minutasByProject}
                purchaseOrders={getCurrentProjectPurchaseOrders()}
                advances={getCurrentProjectAdvances()}
                invoices={getCurrentProjectInvoices()}
                contracts={getCurrentProjectContracts()}
                auditLogs={getCurrentProjectAuditLogs()}
                includeWeekendsByProject={includeWeekendsByProject}
                setIncludeWeekendsByProject={setIncludeWeekendsByProject}
                getCurrentProjectIncludeWeekends={getCurrentProjectIncludeWeekends}
                useSupabase={useSupabase}
              />
            )}

            {/* Gesti√≥n de Proyectos */}
        {activeSection === 'project-management' && (
          <ProjectManagementTabs
            projects={projects}
            currentProjectId={currentProjectId}
            setCurrentProjectId={setCurrentProjectId}
            workPackages={[]}
            setWorkPackages={() => {}}
            risks={getCurrentProjectRisks()}
            setRisks={updateCurrentProjectRisks}
            reportingDate={reportingDate}
            setReportingDate={setReportingDate}
            tasks={getCurrentProjectTasks()}
            setTasks={(newTasksOrUpdater) => {
              // Si es una funci√≥n (setter de React), ejecutarla para obtener el array
              if (typeof newTasksOrUpdater === 'function') {
                const currentTasks = getCurrentProjectTasks();
                const newTasks = newTasksOrUpdater(currentTasks);
                updateCurrentProjectTasks(newTasks);
              } else {
                // Si es directamente un array, pasarlo
                updateCurrentProjectTasks(newTasksOrUpdater);
              }
            }}
            importTasks={importTasksToCurrentProject}
            includeWeekends={getCurrentProjectIncludeWeekends()}
            setIncludeWeekends={updateCurrentProjectIncludeWeekends}
            purchaseOrders={getCurrentProjectPurchaseOrders()}
            setPurchaseOrders={updateCurrentProjectPurchaseOrders}
            advances={getCurrentProjectAdvances()}
            setAdvances={updateCurrentProjectAdvances}
            invoices={getCurrentProjectInvoices()}
            setInvoices={updateCurrentProjectInvoices}
            contracts={getCurrentProjectContracts()}
            setContracts={updateCurrentProjectContracts}
            resourceAssignments={getCurrentProjectResourceAssignments()}
            useSupabase={useSupabase}
            updateProjectMinutas={updateProjectMinutas}
              />
            )}

            {/* Gesti√≥n de Miembros de Organizaci√≥n */}
            {activeSection === 'organization-members' && (
              <OrganizationMembers
                currentProject={currentProject}
                useSupabase={useSupabase}
                onMemberAdded={() => {
                  console.log('‚úÖ Nuevo miembro agregado a la organizaci√≥n');
                  // Aqu√≠ podr√≠as agregar l√≥gica adicional si es necesario
                }}
              />
            )}
          </div>
        </main>
        </div>
    </div>
  );
}

// Componente principal de la aplicaci√≥n
function App() {
  return (
    <Router>
      <AuthProvider>
        <ProjectProvider>
          <Routes>
            {/* Rutas de Super-Admin */}
            <Route 
              path="/admin" 
              element={
                <SuperAdminRoute>
                  <SuperAdminDashboard />
                </SuperAdminRoute>
              } 
            />
            <Route 
              path="/admin/organizations/:orgId" 
              element={
                <SuperAdminRoute>
                  <OrganizationDetails />
                </SuperAdminRoute>
              } 
            />
            
            {/* Ruta principal - App normal */}
            <Route path="/*" element={<AppContent />} />
          </Routes>
        </ProjectProvider>
      </AuthProvider>
    </Router>
  );
}

// Componente que maneja el splash screen y la autenticaci√≥n
function AppContent() {
  const { showSplash, completeSplash, isAuthenticated } = useAuth();

  // Si est√° mostrando splash screen, no verificar autenticaci√≥n
  if (showSplash) {
    return <SplashScreen onComplete={completeSplash} />;
  }

  // DESACTIVAR AUTENTICACI√ìN - Cargar directamente MainApp
  return <MainApp />;
}

export default App;
