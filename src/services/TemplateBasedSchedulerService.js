/**
 * TemplateBasedSchedulerService - Servicio basado en template real
 * StrategiaPM - MVP Implementation
 */

import * as XLSX from 'xlsx';

class TemplateBasedSchedulerService {
  constructor() {
    this.templateData = null;
    this.templatePath = './template-compra-equipos.xlsx';
  }

  /**
   * Cargar template desde datos hardcodeados (basado en an√°lisis previo)
   */
  async loadTemplate() {
    try {
      console.log('üìã Cargando template de compra de equipos...');
      
      // Datos del template extra√≠dos del an√°lisis previo
      const templateData = [
        ['#', 'Nombre', 'Duraci√≥n', 'Prioridad', 'Asignado', 'Predecesoras', 'Hitos'],
        [1, 'Aprobaci√≥n y alta del activo en sistema', '22 d√≠as', 'Alta', 'Team leader', '', 'No'],
        [2, 'Elaboraci√≥n de edital t√©cnico', '5 d√≠as', 'Alta', 'Team leader', '', 'No'],
        [3, 'Env√≠o de edital a proveedores para participar en el proyecto', '5 d√≠as', 'Media', 'Comprador(a)', 2, 'No'],
        [4, 'Soluci√≥n de dudas t√©cnicas', '11 d√≠as', 'Media', 'Proveedores', 3, 'No'],
        [5, 'Selecci√≥n de proveedor', '3 d√≠as', 'Alta', 'Comprador(a)', 4, 'No'],
        [6, 'Preparaci√≥n de contrato con √°rea legal', '7 d√≠as', 'Alta', 'Comprador(a)', 5, 'No'],
        [7, 'Alta del proveedor en sistema para pago', '10 d√≠as', 'Alta', 'Comprador(a)', 5, 'No'],
        [8, 'Definir el equipo de proyecto', '1 d√≠a', 'Media', 'Project Manager', 5, 'No'],
        [9, 'Kick-off meeting con proveedor seleccionado', '1 d√≠a', 'Media', 'Comprador(a)', 8, 'No'],
        [10, 'Hito: Orden de compra realizada', '0 d√≠as', 'Alta', 'Comprador(a)', 9, 'Si'],
        [11, 'Programaci√≥n de 1er anticipo', '12 d√≠as', 'Alta', 'Comprador(a)', 10, 'No'],
        [12, 'Ajuste del cronograma', '1 d√≠a', 'Media', 'Project Manager', 11, 'No'],
        [13, 'HITO: 1er anticipo pagado', '0 d√≠as', 'Alta', 'Tesorero', 11, 'Si'],
        [14, 'Estudio de sitio', '2 d√≠as', 'Media', 'Team leader', 9, 'No'],
        [15, 'Dise√±o de layout y distribuci√≥n de equipos', '5 d√≠as', 'Media', 'Team leader', 14, 'No'],
        [16, 'Especificaciones t√©cnicas finales', '3 d√≠as', 'Alta', 'Team leader', 15, 'No'],
        [17, 'Ingenier√≠a de servicios (vapor, aire, electricidad)', '4 d√≠as', 'Media', 'Team leader', 16, 'No'],
        [18, 'Plan de instalaci√≥n y cronograma detallado', '1 d√≠a', 'Media', 'Team leader', 17, 'No'],
        [19, 'An√°lisis de riesgos de importaci√≥n', '1 d√≠a', 'Media', 'Project Manager', 18, 'No'],
        [20, 'HITO: Dise√±o Aprobado', '0 d√≠as', 'Alta', 'Team leader', 19, 'Si'],
        [21, 'Licitaci√≥n para instalaci√≥n de servicios e infraestructura', '20 d√≠as', 'Media', 'Comprador(a)', 20, 'No'],
        [22, 'HITO: Orden de compra para servicios e infraestructura', '0 d√≠as', 'Alta', 'Comprador(a)', 21, 'Si'],
        [23, 'Gesti√≥n para pago de 1er anticipo de servicios e infraestructura', '12 d√≠as', 'Alta', 'Comprador(a)', 22, 'No'],
        [24, 'HITO: 1er anticipo serv e infraestructura pagado', '0 d√≠as', 'Alta', 'Tesorero', 23, 'Si'],
        [25, 'Preparaci√≥n de cimentaci√≥n y bases (piso)', '21 d√≠as', 'Media', 'Proveedores', 24, 'No'],
        [26, 'Instalaci√≥n de servicios el√©ctricos (220V/440V)', '5 d√≠as', 'Media', 'Proveedores', 25, 'No'],
        [27, 'Instalaci√≥n de l√≠neas de vapor', '5 d√≠as', 'Media', 'Proveedores', 25, 'No'],
        [28, 'Preparaci√≥n de conexiones de aire comprimido', '3 d√≠as', 'Media', 'Proveedores', 27, 'No'],
        [29, 'Instalaci√≥n de sistemas de drenaje', '5 d√≠as', 'Media', 'Proveedores', 26, 'No'],
        [30, 'Adecuaciones de espacio y accesos', '4 d√≠as', 'Media', 'Proveedores', 29, 'No'],
        [31, 'Instalaci√≥n de sistemas de seguridad', '2 d√≠as', 'Media', 'Proveedores', 30, 'No'],
        [32, 'HITO: Sitio Preparado', '0 d√≠as', 'Alta', 'Team leader', 31, 'Si'],
        [33, 'Gesti√≥n para pago 2o anticipo de serv e infraestructura', '12 d√≠as', 'Alta', 'Comprador(a)', 32, 'No'],
        [34, 'HITO: 2o anticipo pagado serv e infraestructura', '0 d√≠as', 'Alta', 'Tesorero', 33, 'Si'],
        [35, 'Gesti√≥n entrada √∫ltima factura de serv e infraestructura', '100 d√≠as', 'Alta', 'Team leader', 32, 'No'],
        [36, 'HITO: Factura pagada de serv e infraestructura', '0 d√≠as', 'Alta', 'Tesorero', 35, 'Si'],
        [37, 'Inicio de fabricaci√≥n de maquinaria', '1 d√≠a', 'Alta', 'Proveedores', 13, 'No'],
        [38, 'Control de calidad durante fabricaci√≥n', '100 d√≠as', 'Media', 'Proveedores', 37, 'No'],
        [39, 'Inspecci√≥n intermedia', '5 d√≠as', 'Media', 'Team leader', 38, 'No'],
        [40, 'Pruebas de f√°brica (FAT)', '10 d√≠as', 'Alta', 'Project Manager', 38, 'No'],
        [41, 'Gesti√≥n de 2o anticipo de pago', '12 d√≠as', 'Alta', 'Comprador(a)', 40, 'No'],
        [42, 'HITO: 2o anticipo linea de salsas pagado', '0 d√≠as', 'Alta', 'Tesorero', 41, 'Si'],
        [43, 'Preparaci√≥n para env√≠o y embalaje', '10 d√≠as', 'Media', 'Proveedores', 38, 'No'],
        [44, 'HITO: FAT Completado', '0 d√≠as', 'Alta', 'Project Manager', 43, 'Si'],
        [45, 'Transporte terrestre a puerto', '2 d√≠as', 'Media', 'Proveedores', 44, 'No'],
        [46, 'Tr√°mites de exportaci√≥n en origen', '1 d√≠a', 'Media', 'Proveedores', 45, 'No'],
        [47, 'Transporte a√©reo Origen - Destino', '2 d√≠as', 'Media', 'Proveedores', 46, 'No'],
        [48, 'Tr√°mites de importaci√≥n', '5 d√≠as', 'Media', 'Proveedores', 47, 'No'],
        [49, 'Liberaci√≥n aduanal', '5 d√≠as', 'Media', 'Proveedores', 48, 'No'],
        [50, 'Transporte hacia Destino', '2 d√≠as', 'Alta', 'Proveedores', 49, 'No'],
        [51, 'HITO: Maquinaria entregada a Destino', '0 d√≠as', 'Alta', 'Proveedores', 50, 'Si'],
        [52, 'Recepci√≥n e inspecci√≥n de equipos', '1 d√≠a', 'Media', 'Team leader', 50, 'No'],
        [53, 'Descarga y posicionamiento', '2 d√≠as', 'Media', 'Team leader', 32, 'No'],
        [54, 'Montaje de equipos', '3 d√≠as', 'Media', 'Team leader', 53, 'No'],
        [55, 'Conexiones el√©ctricas y de control', '2 d√≠as', 'Media', 'Team leader', 54, 'No'],
        [56, 'Conexiones de vapor y aire comprimido', '2 d√≠as', 'Media', 'Team leader', 55, 'No'],
        [57, 'Integraci√≥n de maquinaria', '2 d√≠as', 'Media', 'Team leader', 56, 'No'],
        [58, 'Instalaci√≥n de sistemas de seguridad', '2 d√≠as', 'Media', 'Team leader', 57, 'No'],
        [59, 'HITO: Instalaci√≥n de maquinaria completada', '0 d√≠as', 'Alta', 'Team leader', 58, 'Si'],
        [60, 'Pruebas de integraci√≥n', '1 d√≠a', 'Alta', 'Team leader', 59, 'No'],
        [61, 'Validaci√≥n de procesos', '1 d√≠a', 'Alta', 'Team leader', 60, 'No'],
        [62, 'Documentaci√≥n de resultados', '0 d√≠as', 'Alta', 'Team leader', 61, 'No'],
        [63, 'HITO: Pruebas Exitosas', '0 d√≠as', 'Alta', 'Team leader', 62, 'Si'],
        [64, 'Gesti√≥n de pago de 3er anticipo', '12 d√≠as', 'Alta', 'Comprador(a)', 63, 'No'],
        [65, 'HITO: 3er anticipo pagado', '0 d√≠as', 'Alta', 'Comprador(a)', 64, 'Si'],
        [66, 'Capacitaci√≥n a operadores', '2 d√≠as', 'Media', 'Proveedores', 65, 'No'],
        [67, 'Capacitaci√≥n a personal de mantenimiento', '2 d√≠as', 'Media', 'Proveedores', 63, 'No'],
        [68, 'Capacitaci√≥n en control de calidad', '1 d√≠a', 'Media', 'Proveedores', 63, 'No'],
        [69, 'Entrega de manuales y documentaci√≥n', '0 d√≠as', 'Media', 'Proveedores', 68, 'No'],
        [70, 'Certificaci√≥n final de equipos', '1 d√≠a', 'Media', 'Project Manager', 69, 'No'],
        [71, 'HITO: Personal Capacitado', '0 d√≠as', 'Alta', 'Team leader', 70, 'Si'],
        [72, 'Evaluaci√≥n post-implementaci√≥n', '2 d√≠as', 'Media', 'Project Manager', 71, 'No'],
        [73, 'Documentaci√≥n de lecciones aprendidas', '2 d√≠as', 'Media', 'Team leader', 72, 'No'],
        [74, 'Entrega de garant√≠as y seguros', '1 d√≠a', 'Media', 'Team leader', 73, 'No'],
        [75, 'Cierre administrativo y financiero', '1 d√≠a', 'Media', 'Project Manager', 73, 'No'],
        [76, 'HITO: Proyecto completado', '0 d√≠as', 'Media', 'Project Manager', 75, 'Si']
      ];
      
      this.templateData = this.parseTemplateData(templateData);
      console.log('‚úÖ Template cargado exitosamente:', this.templateData.activities.length, 'actividades');
      
      return this.templateData;
    } catch (error) {
      console.error('‚ùå Error cargando template:', error);
      throw error;
    }
  }

  /**
   * Parsear datos del template
   */
  parseTemplateData(data) {
    const activities = [];
    const milestones = [];
    
    data.slice(1).forEach((row, index) => {
      if (row && row.length > 0 && row[1] && row[1].trim() !== '') {
        const activity = {
          id: row[0], // CORRECCI√ìN: Usar n√∫mero simple en lugar de template-X
          originalId: row[0],
          name: row[1].trim(),
          duration: this.parseDuration(row[2]),
          priority: this.parsePriority(row[3]),
          responsible: row[4]?.trim() || 'Sin asignar',
          predecessor: row[5] || null,
          isMilestone: row[6] === 'Si' || row[1].toLowerCase().includes('hito'),
          category: this.categorizeActivity(row[1]),
          phase: this.determinePhase(row[1], row[0]),
          templateBased: true,
          customizable: this.isCustomizable(row[1], row[0])
        };

        activities.push(activity);
        
        if (activity.isMilestone) {
          milestones.push({
            id: activity.id,
            name: activity.name,
            phase: activity.phase,
            description: `Hito: ${activity.name}`
          });
        }
      }
    });

    return {
      activities,
      milestones,
      metadata: {
        totalActivities: activities.length,
        totalMilestones: milestones.length,
        templateVersion: '1.0',
        loadedAt: new Date().toISOString()
      }
    };
  }

  /**
   * Parsear duraci√≥n del template
   */
  parseDuration(durationStr) {
    if (!durationStr) return 1;
    
    const match = durationStr.toString().match(/(\d+)/);
    return match ? parseInt(match[1]) : 1;
  }

  /**
   * Parsear prioridad del template
   */
  parsePriority(priorityStr) {
    if (!priorityStr) return 'medium';
    
    const priority = priorityStr.toLowerCase();
    if (priority.includes('alta')) return 'high';
    if (priority.includes('media')) return 'medium';
    if (priority.includes('baja')) return 'low';
    return 'medium';
  }

  /**
   * Categorizar actividad
   */
  categorizeActivity(activityName) {
    const name = activityName.toLowerCase();
    
    if (name.includes('hito') || name.includes('aprobaci√≥n') || name.includes('contrato')) {
      return 'milestone';
    } else if (name.includes('fabricaci√≥n') || name.includes('producci√≥n') || name.includes('manufactura')) {
      return 'manufacturing';
    } else if (name.includes('importaci√≥n') || name.includes('aduana') || name.includes('embarque')) {
      return 'import';
    } else if (name.includes('instalaci√≥n') || name.includes('montaje') || name.includes('conexi√≥n')) {
      return 'installation';
    } else if (name.includes('prueba') || name.includes('test') || name.includes('validaci√≥n')) {
      return 'testing';
    } else if (name.includes('capacitaci√≥n') || name.includes('entrenamiento')) {
      return 'training';
    } else if (name.includes('infraestructura') || name.includes('servicios') || name.includes('cimentaci√≥n')) {
      return 'infrastructure';
    } else if (name.includes('anticipo') || name.includes('pago')) {
      return 'financial';
    }
    
    return 'general';
  }

  /**
   * Determinar fase de la actividad
   */
  determinePhase(activityName, activityId) {
    const id = parseInt(activityId);
    
    if (id >= 1 && id <= 13) return 'Planificaci√≥n';
    if (id >= 14 && id <= 20) return 'Dise√±o';
    if (id >= 21 && id <= 36) return 'Infraestructura';
    if (id >= 37 && id <= 44) return 'Fabricaci√≥n';
    if (id >= 45 && id <= 51) return 'Importaci√≥n';
    if (id >= 52 && id <= 63) return 'Instalaci√≥n';
    if (id >= 64 && id <= 76) return 'Cierre';
    
    return 'General';
  }

  /**
   * Determinar si una actividad es personalizable
   */
  isCustomizable(activityName, activityId) {
    const name = activityName.toLowerCase();
    const id = parseInt(activityId);
    
    // Tiempo de fabricaci√≥n
    if (id === 38 && name.includes('fabricaci√≥n')) return { type: 'manufacturing_time', field: 'duration' };
    
    // Anticipos
    if (id === 11 && name.includes('anticipo')) return { type: 'payment_timing', field: 'predecessor' };
    if (id === 41 && name.includes('anticipo')) return { type: 'payment_timing', field: 'predecessor' };
    if (id === 64 && name.includes('anticipo')) return { type: 'payment_timing', field: 'predecessor' };
    
    // Actividades condicionales
    if (id >= 45 && id <= 50) return { type: 'conditional', field: 'include', condition: 'isForeignEquipment' };
    if (id >= 25 && id <= 31) return { type: 'conditional', field: 'include', condition: 'requiresInfrastructure' };
    
    return null;
  }

  /**
   * Mapear roles del template con miembros del equipo
   */
  mapTeamRoles(templateRole, teamMembers) {
    const roleMapping = {
      'Team leader': ['team_lead', 'engineer', 'analyst', 'technician'],
      'Comprador(a)': ['buyer', 'specialist', 'analyst'],
      'Project Manager': ['project_manager'],
      'Proveedores': ['external'], // Externo
      'Tesorero': ['other', 'specialist']
    };

    const possibleRoles = roleMapping[templateRole] || ['other'];
    
    // Buscar miembro con rol compatible
    for (const role of possibleRoles) {
      const member = teamMembers.find(m => m.role === role);
      if (member) {
        return {
          assignedTo: member.name,
          role: member.role,
          experience: member.experience
        };
      }
    }

    // Si no se encuentra, asignar al primer miembro disponible
    if (teamMembers.length > 0) {
      const member = teamMembers[0];
      return {
        assignedTo: member.name,
        role: member.role,
        experience: member.experience
      };
    }

    // Fallback
    return {
      assignedTo: 'Sin asignar',
      role: 'other',
      experience: 'intermediate'
    };
  }

  /**
   * Personalizar actividades seg√∫n configuraci√≥n del asistente
   */
  customizeActivities(activities, wizardData) {
    console.log('üîß Personalizando actividades del template...');
    
    return activities.map(activity => {
      const customized = { ...activity };
      
      // Mapear responsable con miembro del equipo
      if (wizardData.teamMembers && wizardData.teamMembers.length > 0) {
        const assignment = this.mapTeamRoles(activity.responsible, wizardData.teamMembers);
        customized.assignedTo = assignment.assignedTo;
        customized.assignedRole = assignment.role;
        customized.assignedExperience = assignment.experience;
      } else {
        customized.assignedTo = activity.responsible;
      }
      
      // Personalizar tiempo de fabricaci√≥n
      if (activity.customizable?.type === 'manufacturing_time') {
        if (wizardData.deliveryTime && wizardData.deliveryTimeUnit) {
          const deliveryDays = this.convertToDays(wizardData.deliveryTime, wizardData.deliveryTimeUnit);
          customized.duration = deliveryDays;
          console.log(`üîß Ajustando "${activity.name}": ${activity.duration}d ‚Üí ${deliveryDays}d (tiempo de entrega)`);
        }
      }
      
      // Personalizar timing de anticipos
      if (activity.customizable?.type === 'payment_timing') {
        // Ajustar predecesora seg√∫n configuraci√≥n de anticipos
        if (wizardData.advancePayments && wizardData.advancePayments.length > 0) {
          const paymentTiming = this.getPaymentTimingFromActivity(activity.originalId);
          const correspondingPayment = wizardData.advancePayments.find(p => p.timing === paymentTiming);
          
          if (correspondingPayment) {
            console.log(`üí∞ Ajustando timing de "${activity.name}" seg√∫n configuraci√≥n: ${correspondingPayment.timing}`);
          }
        }
      }
      
      return customized;
    });
  }

  /**
   * Obtener timing de pago basado en ID de actividad
   */
  getPaymentTimingFromActivity(activityId) {
    switch (parseInt(activityId)) {
      case 11: return 'order';
      case 41: return 'shipping';
      case 64: return 'delivery';
      default: return 'order';
    }
  }

  /**
   * Convertir tiempo a d√≠as
   */
  convertToDays(amount, unit) {
    switch (unit) {
      case 'days':
        return amount;
      case 'weeks':
        return amount * 7;
      case 'months':
        return amount * 30;
      default:
        return amount;
    }
  }

  /**
   * Filtrar actividades condicionales
   */
  filterConditionalActivities(activities, wizardData) {
    console.log('üîç Filtrando actividades condicionales...');
    
    return activities.filter(activity => {
      if (!activity.customizable) return true;
      
      if (activity.customizable.type === 'conditional') {
        const condition = activity.customizable.condition;
        
        if (condition === 'isForeignEquipment') {
          const include = wizardData.isForeignEquipment === true;
          console.log(`${include ? '‚úÖ' : '‚ùå'} ${include ? 'Incluyendo' : 'Excluyendo'} actividad de importaci√≥n: ${activity.name}`);
          return include;
        }
        
        if (condition === 'requiresInfrastructure') {
          const include = wizardData.requiresInfrastructure === true;
          console.log(`${include ? '‚úÖ' : '‚ùå'} ${include ? 'Incluyendo' : 'Excluyendo'} actividad de infraestructura: ${activity.name}`);
          return include;
        }
      }
      
      return true;
    });
  }

  /**
   * Generar cronograma basado en template
   */
  async generateTemplateBasedSchedule(wizardData) {
    try {
      console.log('üöÄ TEMPLATE-BASED SCHEDULER: Iniciando generaci√≥n...');
      console.log('üìã Wizard Data:', wizardData);
      
      // 1. Cargar template si no est√° cargado
      if (!this.templateData) {
        console.log('üìã Cargando template...');
        await this.loadTemplate();
      }
      
      // 2. Personalizar actividades
      console.log('üîß Personalizando actividades...');
      let activities = this.customizeActivities(this.templateData.activities, wizardData);
      console.log('üîß Actividades personalizadas:', activities.length);
      
      // 3. Filtrar actividades condicionales
      console.log('üîß Filtrando actividades condicionales...');
      activities = this.filterConditionalActivities(activities, wizardData);
      console.log('üîß Actividades filtradas:', activities.length);
      
      // 4. Filtrar hitos
      console.log('üîß Filtrando hitos...');
      const milestones = this.templateData.milestones.filter(milestone => {
        const activity = activities.find(a => a.id === milestone.id);
        return activity !== undefined;
      });
      console.log('üîß Hitos filtrados:', milestones.length);
      
      // 5. Calcular ruta cr√≠tica y aplicar dependencias
      console.log('üîß Calculando ruta cr√≠tica y dependencias...');
      const criticalPathResult = this.calculateCriticalPath(activities);
      const activitiesWithDependencies = criticalPathResult.activities;
      const criticalPath = criticalPathResult.criticalPath;
      console.log('üîß Actividades con dependencias:', activitiesWithDependencies.length);
      
      // 6. Generar recomendaciones
      const recommendations = this.generateRecommendations(wizardData, activitiesWithDependencies);
      
      const generatedSchedule = {
        activities: activitiesWithDependencies,
        milestones,
        criticalPath,
        recommendations,
        metadata: {
          templateUsed: 'Template compra de equipos.xlsx',
          templateId: 'template-compra-equipos-v1',
          generatedAt: new Date().toISOString(),
          wizardData,
          estimatedDuration: this.calculateTotalDuration(activities),
          complexity: this.assessComplexity(wizardData, activities),
          customizationApplied: {
            manufacturingTime: wizardData.deliveryTime ? `${wizardData.deliveryTime} ${wizardData.deliveryTimeUnit}` : 'default',
            advancePayments: wizardData.advancePayments?.length || 0,
            infrastructureIncluded: wizardData.requiresInfrastructure || false,
            importIncluded: wizardData.isForeignEquipment || false
          }
        }
      };
      
      console.log('‚úÖ TEMPLATE-BASED SCHEDULER: Cronograma generado exitosamente');
      console.log(`üìä Actividades: ${activities.length}, Hitos: ${milestones.length}`);
      console.log('üìÖ Primeras 5 actividades con fechas:');
      activitiesWithDependencies.slice(0, 5).forEach((activity, index) => {
        console.log(`  ${index + 1}. ${activity.name}: ${activity.startDate} - ${activity.endDate}`);
      });
      
      return generatedSchedule;
      
    } catch (error) {
      console.error('‚ùå TEMPLATE-BASED SCHEDULER: Error generando cronograma:', error);
      throw error;
    }
  }

  /**
   * Calcular ruta cr√≠tica y aplicar dependencias
   */
  calculateCriticalPath(activities) {
    // Aplicar dependencias del template
    const activitiesWithDependencies = this.applyDependencies(activities);
    
    // Calcular fechas basadas en dependencias
    const activitiesWithDates = this.calculateDates(activitiesWithDependencies);
    
    // Identificar ruta cr√≠tica
    const criticalPath = this.identifyCriticalPath(activitiesWithDates);
    
    return {
      activities: activitiesWithDates,
      criticalPath: criticalPath
    };
  }

  /**
   * Aplicar dependencias del template
   */
  applyDependencies(activities) {
    console.log('üîó Aplicando dependencias del template...');
    
    const result = activities.map(activity => {
      const dependencies = [];
      
      if (activity.predecessor && activity.predecessor !== '') {
        // Buscar la actividad predecesora
        const predecessorActivity = activities.find(a => a.originalId === activity.predecessor);
        if (predecessorActivity) {
          dependencies.push(predecessorActivity.id);
          console.log(`üîó ${activity.name} (ID: ${activity.id}) depende de ${predecessorActivity.name} (ID: ${predecessorActivity.id})`);
        } else {
          console.warn(`‚ö†Ô∏è Predecesora ${activity.predecessor} no encontrada para ${activity.name}`);
        }
      }
      
      return {
        ...activity,
        dependencies: dependencies
      };
    });
    
    // Verificar dependencias circulares
    console.log('üîç Verificando dependencias circulares...');
    const hasCircularDependency = this.checkCircularDependencies(result);
    if (hasCircularDependency) {
      console.error('‚ùå Se detectaron dependencias circulares en el template!');
    } else {
      console.log('‚úÖ No se detectaron dependencias circulares');
    }
    
    return result;
  }
  
  /**
   * Verificar dependencias circulares
   */
  checkCircularDependencies(activities) {
    const visited = new Set();
    const recursionStack = new Set();
    
    const hasCycle = (activityId) => {
      if (recursionStack.has(activityId)) {
        console.error(`‚ùå Dependencia circular detectada: ${activityId}`);
        return true;
      }
      if (visited.has(activityId)) {
        return false;
      }
      
      visited.add(activityId);
      recursionStack.add(activityId);
      
      const activity = activities.find(a => a.id === activityId);
      if (activity) {
        for (const depId of activity.dependencies) {
          if (hasCycle(depId)) {
            return true;
          }
        }
      }
      
      recursionStack.delete(activityId);
      return false;
    };
    
    for (const activity of activities) {
      if (!visited.has(activity.id)) {
        if (hasCycle(activity.id)) {
          return true;
        }
      }
    }
    
    return false;
  }

  /**
   * Calcular fechas basadas en dependencias (algoritmo robusto)
   */
  calculateDates(activities) {
    console.log('üìÖ Calculando fechas basadas en dependencias (algoritmo robusto)...');
    
    const activitiesWithDates = [...activities];
    const startDate = new Date('2025-09-28'); // Fecha de inicio del proyecto
    
    // Inicializar todas las actividades sin fechas
    activitiesWithDates.forEach(activity => {
      activity.startDate = null;
      activity.endDate = null;
    });
    
    // Crear mapa de actividades por ID para acceso r√°pido
    const activityMap = new Map();
    activitiesWithDates.forEach(activity => {
      activityMap.set(activity.id, activity);
    });
    
    // Funci√≥n para calcular fechas de una actividad
    const calculateActivityDates = (activity) => {
      if (activity.startDate && activity.endDate) {
        return; // Ya calculada
      }
      
      console.log(`üîç Calculando: ${activity.name} (ID: ${activity.originalId})`);
      
      let activityStartDate = new Date(startDate);
      
      if (activity.dependencies.length > 0) {
        console.log(`üîó Dependencias de ${activity.name}:`, activity.dependencies);
        
        // Calcular fechas de todas las dependencias primero
        activity.dependencies.forEach(depId => {
          const depActivity = activityMap.get(depId);
          if (depActivity) {
            calculateActivityDates(depActivity); // Recursivo
          }
        });
        
        // Encontrar la fecha de fin m√°s tard√≠a de las dependencias
        let latestDependencyEnd = null;
        
        activity.dependencies.forEach(depId => {
          const depActivity = activityMap.get(depId);
          if (depActivity && depActivity.endDate) {
            console.log(`  üìÖ Dependencia ${depActivity.name} termina: ${depActivity.endDate.toLocaleDateString()}`);
            if (!latestDependencyEnd || depActivity.endDate > latestDependencyEnd) {
              latestDependencyEnd = new Date(depActivity.endDate);
            }
          }
        });
        
        if (latestDependencyEnd) {
          // La actividad inicia el d√≠a siguiente al fin de la √∫ltima dependencia
          activityStartDate = new Date(latestDependencyEnd);
          activityStartDate.setDate(activityStartDate.getDate() + 1);
          console.log(`‚úÖ ${activity.name} inicia despu√©s de dependencias: ${activityStartDate.toLocaleDateString()}`);
        }
      } else {
        console.log(`üìÖ ${activity.name} sin dependencias, inicia en: ${activityStartDate.toLocaleDateString()}`);
      }
      
      // Calcular fecha de fin
      const activityEndDate = new Date(activityStartDate);
      activityEndDate.setDate(activityEndDate.getDate() + activity.duration - 1); // -1 porque el primer d√≠a cuenta
      
      // Actualizar fechas en la actividad
      activity.startDate = activityStartDate;
      activity.endDate = activityEndDate;
      
      // Tambi√©n actualizar earlyStart y earlyFinish para CPM
      activity.earlyStart = activityStartDate;
      activity.earlyFinish = activityEndDate;
      
      // Marcar como calculada por template para evitar que CPM la sobrescriba
      activity.templateCalculated = true;
      
      console.log(`üìÖ ${activity.name}: ${activityStartDate.toLocaleDateString()} - ${activityEndDate.toLocaleDateString()} (${activity.duration} d√≠as)`);
    };
    
    // Procesar actividades en orden de ID original (1, 2, 3, 4...)
    const sortedActivities = [...activitiesWithDates].sort((a, b) => a.originalId - b.originalId);
    
    // Calcular fechas de todas las actividades
    sortedActivities.forEach(activity => {
      calculateActivityDates(activity);
    });
    
    // Verificar que todas las dependencias se respeten
    console.log('üîç Verificando dependencias...');
    activitiesWithDates.forEach(activity => {
      if (activity.dependencies.length > 0) {
        activity.dependencies.forEach(depId => {
          const depActivity = activityMap.get(depId);
          if (depActivity && depActivity.endDate && activity.startDate) {
            if (activity.startDate <= depActivity.endDate) {
              console.error(`‚ùå ERROR: ${activity.name} inicia ${activity.startDate.toLocaleDateString()} pero su dependencia ${depActivity.name} termina ${depActivity.endDate.toLocaleDateString()}`);
            } else {
              console.log(`‚úÖ OK: ${activity.name} inicia ${activity.startDate.toLocaleDateString()} despu√©s de ${depActivity.name} que termina ${depActivity.endDate.toLocaleDateString()}`);
            }
          }
        });
      }
    });
    
    return activitiesWithDates;
  }

  /**
   * Ordenamiento topol√≥gico para respetar dependencias
   */
  topologicalSort(activities) {
    console.log('üîÑ Iniciando ordenamiento topol√≥gico...');
    
    const visited = new Set();
    const temp = new Set();
    const result = [];
    
    const visit = (activity) => {
      if (temp.has(activity.id)) {
        throw new Error('Dependencia circular detectada');
      }
      if (visited.has(activity.id)) {
        return;
      }
      
      temp.add(activity.id);
      console.log(`üîç Visitando: ${activity.name} (ID: ${activity.id})`);
      
      // Visitar dependencias primero
      activity.dependencies.forEach(depId => {
        const depActivity = activities.find(a => a.id === depId);
        if (depActivity) {
          console.log(`  ‚Ü≥ Dependencia: ${depActivity.name} (ID: ${depId})`);
          visit(depActivity);
        }
      });
      
      temp.delete(activity.id);
      visited.add(activity.id);
      result.push(activity);
      console.log(`‚úÖ Agregado a resultado: ${activity.name}`);
    };
    
    // Procesar actividades en orden de ID original para consistencia
    const sortedByOriginalId = [...activities].sort((a, b) => a.originalId - b.originalId);
    
    sortedByOriginalId.forEach(activity => {
      if (!visited.has(activity.id)) {
        visit(activity);
      }
    });
    
    console.log('üîÑ Ordenamiento topol√≥gico completado. Orden final:');
    result.forEach((activity, index) => {
      console.log(`  ${index + 1}. ${activity.name} (ID: ${activity.id})`);
    });
    
    return result;
  }

  /**
   * Identificar ruta cr√≠tica
   */
  identifyCriticalPath(activities) {
    // Actividades de alta prioridad y sin holgura
    return activities.filter(activity => 
      activity.priority === 'high' || activity.isMilestone
    );
  }

  /**
   * Generar recomendaciones
   */
  generateRecommendations(wizardData, activities) {
    const recommendations = [];
    
    if (wizardData.isForeignEquipment) {
      recommendations.push({
        type: 'info',
        title: 'Equipo Extranjero',
        message: 'Se incluyeron actividades de importaci√≥n y aduanas en el cronograma.'
      });
    }
    
    if (wizardData.requiresInfrastructure) {
      recommendations.push({
        type: 'info',
        title: 'Infraestructura Requerida',
        message: 'Se incluyeron actividades de preparaci√≥n de sitio e infraestructura.'
      });
    }
    
    if (wizardData.advancePayments && wizardData.advancePayments.length > 0) {
      recommendations.push({
        type: 'financial',
        title: 'Anticipos Configurados',
        message: `Se configuraron ${wizardData.advancePayments.length} anticipos seg√∫n tus especificaciones.`
      });
    }
    
    return recommendations;
  }

  /**
   * Calcular duraci√≥n total
   */
  calculateTotalDuration(activities) {
    return activities.reduce((total, activity) => total + activity.duration, 0);
  }

  /**
   * Evaluar complejidad
   */
  assessComplexity(wizardData, activities) {
    let complexity = 'medium';
    
    if (activities.length > 50) complexity = 'high';
    else if (activities.length < 30) complexity = 'low';
    
    if (wizardData.isForeignEquipment && wizardData.requiresInfrastructure) {
      complexity = 'high';
    }
    
    return complexity;
  }
}

// Exportar como singleton
const templateBasedSchedulerService = new TemplateBasedSchedulerService();
export default templateBasedSchedulerService;
