import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import './App.css';
import './index.css';

// Componentes
import LoginForm from './components/LoginForm';
import ProtectedRoute from './components/ProtectedRoute';
import Sidebar from './components/Sidebar';
import ConsolidatedDashboard from './components/ConsolidatedDashboard';
import IntegratedPMODashboard from './components/IntegratedPMODashboard';
import PortfolioStrategic from './components/PortfolioStrategic';
import ProjectManagementTabs from './components/ProjectManagementTabs';
import ScheduleManagement from './components/ScheduleManagement';
import FinancialManagement from './components/FinancialManagement';
import ResourceManagement from './components/ResourceManagement';
import RiskManagement from './components/RiskManagement';
import ChangeManagement from './components/ChangeManagement';
import CashFlowProjection from './components/CashFlowProjection';
import FileManager from './components/FileManager';
import ReportsManagement from './components/ReportsManagement';
import ProjectAudit from './components/ProjectAudit';
import ProjectArchive from './components/ProjectArchive';
import SyncIndicator from './components/SyncIndicator';
import BackupManager from './components/BackupManager';
import DataManager from './components/DataManager';
import FileStatusIndicator from './components/FileStatusIndicator';
import filePersistenceService from './services/FilePersistenceService';

// Contextos
import { AuthProvider, useAuth } from './contexts/AuthContext';
import { ProjectProvider } from './contexts/ProjectContext';

// Componente principal de la aplicaci√≥n (requiere autenticaci√≥n)
function MainApp() {
  const { user } = useAuth();
  
  // ===== ESTADO MULTI-PROYECTO =====
  const [projects, setProjects] = useState([
    // Proyecto de demostraci√≥n para familiarizarse con el sistema
    {
      id: 'demo-001',
      name: 'Proyecto de Demostraci√≥n',
      description: 'Proyecto de ejemplo para familiarizarse con el sistema. Puede eliminarse cuando agregue sus proyectos reales.',
      status: 'active',
      priority: 'medium',
      startDate: new Date().toISOString().split('T')[0],
      endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 d√≠as desde hoy
      budget: 100000,
      contingencyReserve: 10000,
      managementReserve: 5000,
      manager: 'Usuario Demo',
      sponsor: 'Organizaci√≥n',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: '1.0.0',
      progress: 0
    }
  ]);

  // Funci√≥n para obtener el proyecto inicial con l√≥gica de respaldo
  const getInitialProjectId = () => {
    // 1. Intentar cargar el √∫ltimo proyecto seleccionado desde localStorage
    const lastSelectedProjectId = localStorage.getItem('lastSelectedProjectId');
    
    if (lastSelectedProjectId) {
      // Verificar si el proyecto a√∫n existe y est√° activo
      const project = projects.find(p => p.id === lastSelectedProjectId);
      if (project && project.status === 'active') {
        return lastSelectedProjectId;
      }
    }
    
    // 2. Si no hay proyecto seleccionado o no est√° activo, buscar el primer proyecto activo
    const activeProject = projects.find(p => p.status === 'active');
    if (activeProject) {
      return activeProject.id;
    }
    
    // 3. Si no hay proyectos activos, usar el primer proyecto disponible
    if (projects.length > 0) {
      return projects[0].id;
    }
    
    // 4. Fallback por defecto
    return 'demo-001';
  };

  const [currentProjectId, setCurrentProjectId] = useState(getInitialProjectId);
  const [portfolioViewMode, setPortfolioViewMode] = useState('portfolio'); // 'portfolio', 'project', 'schedule'
  const [viewMode, setViewMode] = useState('dashboard');

  // Corregir currentProjectId si no coincide con ning√∫n proyecto existente
  useEffect(() => {
    if (projects && projects.length > 0) {
      const projectExists = projects.find(p => p.id === currentProjectId);
      if (!projectExists) {
        // Buscar el primer proyecto activo disponible
        const activeProject = projects.find(p => p.status === 'active');
        const fallbackProjectId = activeProject ? activeProject.id : projects[0].id;
        
        console.log('üîß CORRIGIENDO currentProjectId:', {
          currentProjectId,
          availableProjects: projects.map(p => ({ id: p.id, name: p.name, status: p.status })),
          fallbackTo: fallbackProjectId,
          reason: 'Proyecto no encontrado, usando primer proyecto disponible'
        });
        setCurrentProjectId(fallbackProjectId);
      }
    }
  }, [projects, currentProjectId]);

  // Work Packages eliminados - ya no se usan

  // Tareas por proyecto - cada proyecto tiene su propio cronograma
  const [tasksByProject, setTasksByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin tareas iniciales
  });

  // Configuraci√≥n de d√≠as laborables por proyecto - cada proyecto puede tener su propia configuraci√≥n
  const [includeWeekendsByProject, setIncludeWeekendsByProject] = useState({
    'demo-001': false // Por defecto: solo d√≠as laborales (lunes a viernes)
  });

  // Funci√≥n para limpiar datos corruptos
  const cleanTasksByProject = (data) => {
    if (!data || typeof data !== 'object') return {};
    
    const cleaned = {};
    Object.keys(data).forEach(projectId => {
      const projectTasks = data[projectId];
      if (Array.isArray(projectTasks)) {
        cleaned[projectId] = projectTasks;
      } else {
        console.warn(`‚ö†Ô∏è Limpiando datos corruptos para proyecto ${projectId}:`, typeof projectTasks);
        cleaned[projectId] = [];
      }
    });
    return cleaned;
  };

  // Funci√≥n para obtener tareas del proyecto actual
  const getCurrentProjectTasks = () => {
    // Obtener tareas directamente sin limpiar datos corruptos aqu√≠
    // La limpieza se hace solo una vez al cargar datos iniciales
    const tasks = tasksByProject[currentProjectId] || [];
    
    // Solo loggear si hay un problema potencial
    if (!Array.isArray(tasks)) {
      console.warn('‚ö†Ô∏è Datos corruptos detectados en getCurrentProjectTasks:', {
        currentProjectId,
        tasksType: typeof tasks,
        tasksValue: tasks
      });
      return []; // Retornar array vac√≠o si hay datos corruptos
    }
    
    return tasks;
  };

  // Ref para controlar si ya se limpiaron los datos corruptos
  const dataCleanedRef = useRef(false);

  // Limpiar datos corruptos SOLO al cargar datos iniciales, no en useEffect
  const cleanCorruptDataOnce = useCallback(() => {
    if (!dataCleanedRef.current && tasksByProject && typeof tasksByProject === 'object' && !Array.isArray(tasksByProject) && Object.keys(tasksByProject).length > 0) {
      // Verificar si hay datos corruptos antes de limpiar
      let hasCorruptData = false;
      for (const [projectId, tasks] of Object.entries(tasksByProject)) {
        if (typeof tasks === 'function' || (tasks && !Array.isArray(tasks))) {
          hasCorruptData = true;
          console.warn('‚ö†Ô∏è Datos corruptos detectados en tasksByProject para proyecto:', projectId, 'tipo:', typeof tasks);
          break;
        }
      }
      
      if (hasCorruptData) {
        const cleanedTasksByProject = cleanTasksByProject(tasksByProject);
        if (cleanedTasksByProject !== tasksByProject) {
          console.warn('‚ö†Ô∏è Datos corruptos detectados en tasksByProject, limpiando...');
          setTasksByProject(cleanedTasksByProject);
        }
      }
      dataCleanedRef.current = true; // Marcar como limpiado SIEMPRE
    }
  }, [tasksByProject]);

  // Funci√≥n para actualizar tareas del proyecto actual
  const updateCurrentProjectTasks = (newTasks) => {
    console.log('üìä updateCurrentProjectTasks - INICIANDO:', {
      currentProjectId,
      newTasksLength: newTasks?.length,
      newTasksType: typeof newTasks
    });
    
    // Validar que newTasks sea un array v√°lido
    if (!Array.isArray(newTasks)) {
      console.error('‚ùå updateCurrentProjectTasks - newTasks NO ES UN ARRAY:', {
        currentProjectId,
        newTasksType: typeof newTasks,
        newTasksValue: newTasks
      });
      return; // No actualizar si no es un array v√°lido
    }
    
    // Solo loggear si hay un problema potencial
    if (newTasks.length === 0) {
      console.warn('‚ö†Ô∏è updateCurrentProjectTasks - TAREAS VAC√çAS:', {
        currentProjectId,
        newTasksLength: newTasks.length
      });
    }
    
    setTasksByProject(prev => {
      console.log('üìä updateCurrentProjectTasks - setTasksByProject INICIANDO:', {
        currentProjectId,
        prevKeys: Object.keys(prev || {}),
        newTasksLength: newTasks.length
      });
      
      // Verificar que prev sea un objeto v√°lido
      if (!prev || typeof prev !== 'object' || Array.isArray(prev)) {
        console.error('‚ùå updateCurrentProjectTasks - prev NO ES UN OBJETO V√ÅLIDO:', {
          prevType: typeof prev,
          prevValue: prev
        });
        return prev; // Retornar prev sin cambios si no es v√°lido
      }
      
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = newTasks;
      
      console.log('üìä updateCurrentProjectTasks - setTasksByProject COMPLETADO:', {
        currentProjectId,
        updatedKeys: Object.keys(updatedProjects),
        tasksInProject: updatedProjects[currentProjectId]?.length
      });
      
      return updatedProjects;
    });
  };

  // Funci√≥n para obtener configuraci√≥n de d√≠as laborables del proyecto actual
  const getCurrentProjectIncludeWeekends = () => {
    return includeWeekendsByProject[currentProjectId] || false;
  };

  // Funci√≥n para actualizar configuraci√≥n de d√≠as laborables del proyecto actual
  const updateCurrentProjectIncludeWeekends = (includeWeekends) => {
    setIncludeWeekendsByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = includeWeekends;
      return updatedProjects;
    });
  };

  // Riesgos por proyecto - cada proyecto tiene su propia gesti√≥n de riesgos
  const [risksByProject, setRisksByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin riesgos iniciales
  });

  // Funci√≥n para obtener riesgos del proyecto actual
  const getCurrentProjectRisks = () => {
    return risksByProject[currentProjectId] || [];
  };

  // Funci√≥n para actualizar riesgos del proyecto actual
  const updateCurrentProjectRisks = (newRisks) => {
    setRisksByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = newRisks;
      return updatedProjects;
    });
  };

  // Funci√≥n para actualizar √≥rdenes de compra del proyecto actual
  const updateCurrentProjectPurchaseOrders = (newPurchaseOrders) => {
    // Validar que newPurchaseOrders sea un array v√°lido
    const safePurchaseOrders = Array.isArray(newPurchaseOrders) ? newPurchaseOrders : [];
    
    console.log('üíæ ACTUALIZANDO √ìRDENES DE COMPRA:', {
      currentProjectId,
      newPurchaseOrdersType: typeof newPurchaseOrders,
      newPurchaseOrdersIsArray: Array.isArray(newPurchaseOrders),
      newPurchaseOrdersLength: safePurchaseOrders.length,
      newPurchaseOrders: safePurchaseOrders
    });
    
    setPurchaseOrdersByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safePurchaseOrders;
      return updatedProjects;
    });
  };

  // Funci√≥n para actualizar anticipos del proyecto actual
  const updateCurrentProjectAdvances = (newAdvances) => {
    const safeAdvances = Array.isArray(newAdvances) ? newAdvances : [];
    console.log('üíæ ACTUALIZANDO ANTICIPOS:', {
      currentProjectId,
      newAdvancesType: typeof newAdvances,
      newAdvancesIsArray: Array.isArray(newAdvances),
      newAdvancesLength: safeAdvances.length
    });
    setAdvancesByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safeAdvances;
      return updatedProjects;
    });
  };

  // Funci√≥n para actualizar facturas del proyecto actual
  const updateCurrentProjectInvoices = (newInvoices) => {
    const safeInvoices = Array.isArray(newInvoices) ? newInvoices : [];
    console.log('üíæ ACTUALIZANDO FACTURAS:', {
      currentProjectId,
      newInvoicesType: typeof newInvoices,
      newInvoicesIsArray: Array.isArray(newInvoices),
      newInvoicesLength: safeInvoices.length
    });
    setInvoicesByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safeInvoices;
      return updatedProjects;
    });
  };

  // Funci√≥n para actualizar contratos del proyecto actual
  const updateCurrentProjectContracts = (newContracts) => {
    const safeContracts = Array.isArray(newContracts) ? newContracts : [];
    console.log('üíæ ACTUALIZANDO CONTRATOS:', {
      currentProjectId,
      newContractsType: typeof newContracts,
      newContractsIsArray: Array.isArray(newContracts),
      newContractsLength: safeContracts.length
    });
    setContractsByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[currentProjectId] = safeContracts;
      return updatedProjects;
    });
  };

  // ===== FUNCIONES DE GESTI√ìN FINANCIERA =====
  
  const [purchaseOrdersByProject, setPurchaseOrdersByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin √≥rdenes iniciales
  });

  const [advancesByProject, setAdvancesByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin anticipos iniciales
  });

  const [invoicesByProject, setInvoicesByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin facturas iniciales
  });

  const [contractsByProject, setContractsByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin contratos iniciales
  });

  const getCurrentProjectPurchaseOrders = () => {
    return purchaseOrdersByProject[currentProjectId] || [];
  };

  const getCurrentProjectAdvances = () => {
    return advancesByProject[currentProjectId] || [];
  };

  const getCurrentProjectInvoices = () => {
    return invoicesByProject[currentProjectId] || [];
  };

  const getCurrentProjectContracts = () => {
    return contractsByProject[currentProjectId] || [];
  };

  // ===== FUNCIONES DE GESTI√ìN DE RECURSOS =====
  
  const [globalResources, setGlobalResources] = useState([]);
  const [resourceAssignmentsByProject, setResourceAssignmentsByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin asignaciones iniciales
  });

  const getCurrentProjectResourceAssignments = () => {
    return resourceAssignmentsByProject[currentProjectId] || [];
  };

  // ===== FUNCIONES DE AUDITOR√çA =====
  
  const [auditLogsByProject, setAuditLogsByProject] = useState({
    'demo-001': [] // Proyecto de demostraci√≥n - sin logs iniciales
  });
  const [dataLoaded, setDataLoaded] = useState(false);

  const getCurrentProjectAuditLogs = () => {
    return auditLogsByProject[currentProjectId] || [];
  };

  // ===== SISTEMA DE PERSISTENCIA =====
  
  // Funci√≥n para guardar y cerrar
  const handleSaveAndClose = async () => {
    try {
      console.log('üíæ Guardando datos antes de cerrar...');
      
      // Crear objeto con todos los datos actuales
      const dataToSave = {
        projects,
        currentProjectId,
        tasksByProject,
        includeWeekendsByProject,
        risksByProject,
        purchaseOrdersByProject,
        advancesByProject,
        invoicesByProject,
        contractsByProject,
        globalResources,
        resourceAssignmentsByProject,
        auditLogsByProject,
        timestamp: new Date().toISOString()
      };

      // Guardar usando el servicio de persistencia (archivo real)
      await filePersistenceService.saveData(dataToSave);
      
      console.log('‚úÖ Datos guardados exitosamente');
      
      // Mostrar confirmaci√≥n
      alert('‚úÖ Datos guardados exitosamente en archivo real. Puedes cerrar la aplicaci√≥n manualmente.');
      
    } catch (error) {
      console.error('‚ùå Error guardando datos:', error);
      alert('‚ùå Error al guardar los datos. Por favor, int√©ntalo de nuevo.');
    }
  };
  
  // Cargar datos del localStorage al iniciar
  useEffect(() => {
    const loadData = async () => {
      try {
        console.log('üöÄ Iniciando carga de datos...');
        
        // Inicializar servicio de persistencia
        console.log('üîß Inicializando filePersistenceService...');
        await filePersistenceService.initialize();
        console.log('‚úÖ filePersistenceService inicializado');
        
        // Cargar datos desde el servicio
        console.log('üîç Llamando a filePersistenceService.loadData()...');
        const savedData = await filePersistenceService.loadData();
        console.log('üîç Resultado de loadData():', savedData);
        
        if (savedData) {
          console.log('üìÇ Datos encontrados, cargando...');
          console.log('üìÇ globalResources en datos guardados:', savedData.globalResources);
          
          if (savedData.projects && Array.isArray(savedData.projects) && savedData.projects.length > 0) {
            console.log('üìÇ Cargando proyectos guardados:', savedData.projects.length);
            setProjects(savedData.projects);
          } else {
            console.log('üìÇ No hay proyectos guardados v√°lidos, manteniendo proyectos iniciales');
          }
          if (savedData.currentProjectId) {
            setCurrentProjectId(savedData.currentProjectId);
          }
          if (savedData.tasksByProject) {
            setTasksByProject(savedData.tasksByProject);
          }
          if (savedData.includeWeekendsByProject) {
            setIncludeWeekendsByProject(savedData.includeWeekendsByProject);
          }
          if (savedData.risksByProject) {
            setRisksByProject(savedData.risksByProject);
          }
          if (savedData.purchaseOrdersByProject) {
            setPurchaseOrdersByProject(savedData.purchaseOrdersByProject);
          }
          if (savedData.advancesByProject) {
            setAdvancesByProject(savedData.advancesByProject);
          }
          if (savedData.invoicesByProject) {
            setInvoicesByProject(savedData.invoicesByProject);
          }
          if (savedData.contractsByProject) {
            setContractsByProject(savedData.contractsByProject);
          }
          if (savedData.globalResources) {
            console.log('üìÇ Estableciendo globalResources:', savedData.globalResources);
            setGlobalResources(savedData.globalResources);
          }
          if (savedData.resourceAssignmentsByProject) {
            setResourceAssignmentsByProject(savedData.resourceAssignmentsByProject);
          }
          if (savedData.auditLogsByProject) {
            setAuditLogsByProject(savedData.auditLogsByProject);
          }
        } else {
          console.log('üìÇ No se encontraron datos guardados');
          console.log('üìÇ savedData es:', savedData);
        }
        
        // Limpiar datos corruptos una sola vez despu√©s de cargar
        cleanCorruptDataOnce();
        
        // Marcar que los datos iniciales se han cargado
        console.log('‚úÖ Marcando dataLoaded como true');
        setDataLoaded(true);
      } catch (error) {
        console.error('‚ùå Error al cargar datos:', error);
        console.error('‚ùå Stack trace:', error.stack);
        // Marcar como cargado incluso si hay error para evitar bloqueo
        setDataLoaded(true);
      }
    };

    loadData();
  }, []);

  // Escuchar eventos de restauraci√≥n e importaci√≥n
  useEffect(() => {
    const handleDataRestore = (event) => {
      const { data } = event.detail;
      
      if (data.projects) setProjects(data.projects);
      if (data.currentProjectId) setCurrentProjectId(data.currentProjectId);
      if (data.tasksByProject) setTasksByProject(data.tasksByProject);
      if (data.risksByProject) setRisksByProject(data.risksByProject);
      if (data.purchaseOrdersByProject) setPurchaseOrdersByProject(data.purchaseOrdersByProject);
      if (data.advancesByProject) setAdvancesByProject(data.advancesByProject);
      if (data.invoicesByProject) setInvoicesByProject(data.invoicesByProject);
      if (data.contractsByProject) setContractsByProject(data.contractsByProject);
      if (data.globalResources) setGlobalResources(data.globalResources);
      if (data.resourceAssignmentsByProject) setResourceAssignmentsByProject(data.resourceAssignmentsByProject);
      if (data.auditLogsByProject) setAuditLogsByProject(data.auditLogsByProject);
    };

    const handleDataImport = (event) => {
      const { data } = event.detail;
      
      if (data.projects) setProjects(data.projects);
      if (data.currentProjectId) setCurrentProjectId(data.currentProjectId);
      if (data.tasksByProject) setTasksByProject(data.tasksByProject);
      if (data.risksByProject) setRisksByProject(data.risksByProject);
      if (data.purchaseOrdersByProject) setPurchaseOrdersByProject(data.purchaseOrdersByProject);
      if (data.advancesByProject) setAdvancesByProject(data.advancesByProject);
      if (data.invoicesByProject) setInvoicesByProject(data.invoicesByProject);
      if (data.contractsByProject) setContractsByProject(data.contractsByProject);
      if (data.globalResources) setGlobalResources(data.globalResources);
      if (data.resourceAssignmentsByProject) setResourceAssignmentsByProject(data.resourceAssignmentsByProject);
      if (data.auditLogsByProject) setAuditLogsByProject(data.auditLogsByProject);
    };

    window.addEventListener('dataRestore', handleDataRestore);
    window.addEventListener('dataImport', handleDataImport);

    return () => {
      window.removeEventListener('dataRestore', handleDataRestore);
      window.removeEventListener('dataImport', handleDataImport);
    };
  }, []);

  // ===== SISTEMA DE GUARDADO CON THROTTLING =====
  
  // Ref para controlar el throttling y evitar bucles infinitos
  const saveTimeoutRef = useRef(null);
  const lastSaveDataRef = useRef(null);
  const isSavingRef = useRef(false);

  // Funci√≥n para comparar si los datos han cambiado realmente
  const hasDataChanged = (newData, oldData) => {
    if (!oldData) return true;
    
    // Comparar solo los campos esenciales para evitar guardados innecesarios
    const essentialFields = [
      'projects', 'currentProjectId', 'tasksByProject', 'risksByProject',
      'globalResources', 'purchaseOrdersByProject', 'advancesByProject',
      'invoicesByProject', 'contractsByProject', 'resourceAssignmentsByProject',
      'auditLogsByProject'
    ];
    
    return essentialFields.some(field => {
      const newValue = newData[field];
      const oldValue = oldData[field];
      
      if (field === 'projects' || field === 'tasksByProject' || field === 'risksByProject' || 
          field === 'globalResources' || field === 'purchaseOrdersByProject' || 
          field === 'advancesByProject' || field === 'invoicesByProject' || 
          field === 'contractsByProject' || field === 'resourceAssignmentsByProject' || 
          field === 'auditLogsByProject') {
        return JSON.stringify(newValue) !== JSON.stringify(oldValue);
      }
      
      return newValue !== oldValue;
    });
  };

  // Funci√≥n de guardado con throttling
  const throttledSave = useCallback((dataToSave) => {
    // Cancelar guardado anterior si existe
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    // Verificar si los datos han cambiado realmente
    if (!hasDataChanged(dataToSave, lastSaveDataRef.current)) {
      console.log('‚è≠Ô∏è Datos sin cambios, omitiendo guardado');
      return;
    }

    // Verificar que no est√© guardando ya
    if (isSavingRef.current) {
      console.log('‚è≥ Ya hay un guardado en progreso, omitiendo');
      return;
    }

    // Guardar con throttling de 1 segundo y cola de guardado
    saveTimeoutRef.current = setTimeout(async () => {
      try {
        isSavingRef.current = true;
        
        console.log('üíæ Guardando datos con throttling...');
        
        // Guardar en localStorage (inmediato) con validaci√≥n
        try {
          localStorage.setItem('mi-dashboard-portfolio', JSON.stringify(dataToSave));
          console.log('‚úÖ Datos guardados en localStorage');
        } catch (error) {
          console.error('‚ùå Error guardando en localStorage:', error);
          // Si localStorage falla, intentar limpiar datos antiguos
          if (error.name === 'QuotaExceededError') {
            console.log('üßπ Espacio insuficiente, limpiando datos antiguos...');
            // Aqu√≠ podr√≠as implementar limpieza de datos antiguos
          }
          throw error;
        }
        
        // Guardar en archivo local (persistente) con reintentos
        let retries = 3;
        while (retries > 0) {
          try {
            await filePersistenceService.saveData(dataToSave);
            break;
          } catch (error) {
            retries--;
            if (retries === 0) throw error;
            console.log(`üîÑ Reintentando guardado... (${retries} intentos restantes)`);
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
        
        // Actualizar referencia de √∫ltimo guardado
        lastSaveDataRef.current = dataToSave;
        
        console.log('‚úÖ Datos guardados exitosamente');
        
        // Disparar evento de sincronizaci√≥n SOLO si es necesario
        // y no estamos en el proceso de carga inicial
        if (dataLoaded) {
          const syncEvent = new CustomEvent('dataSync', { 
            detail: { 
              type: 'portfolio_data_saved', 
              timestamp: new Date().toISOString(),
              source: 'throttled_save'
            } 
          });
          window.dispatchEvent(syncEvent);
        }
        
      } catch (error) {
        console.error('‚ùå Error guardando datos:', error);
      } finally {
        isSavingRef.current = false;
      }
    }, 1000); // Throttling de 1 segundo
  }, [dataLoaded]);

  // Guardar datos cuando cambien (solo despu√©s de cargar datos iniciales)
  useEffect(() => {
    // No guardar hasta que se hayan cargado los datos iniciales
    if (!dataLoaded) {
      console.log('‚è≥ Esperando a que se carguen los datos iniciales...');
      return;
    }

    console.log('üîÑ useEffect GUARDADO - EJECUT√ÅNDOSE:', {
      tasksByProjectKeys: Object.keys(tasksByProject),
      tasksForCurrentProject: tasksByProject[currentProjectId] ? tasksByProject[currentProjectId].length : 'UNDEFINED',
      currentProjectId
    });

    const dataToSave = {
      projects,
      currentProjectId,
      tasksByProject,
      includeWeekendsByProject,
      risksByProject,
      purchaseOrdersByProject,
      advancesByProject,
      invoicesByProject,
      contractsByProject,
      globalResources,
      resourceAssignmentsByProject,
      auditLogsByProject,
      timestamp: new Date().toISOString()
    };

    // Usar funci√≥n de guardado con throttling
    throttledSave(dataToSave);
  }, [projects, currentProjectId, includeWeekendsByProject, risksByProject, purchaseOrdersByProject, advancesByProject, invoicesByProject, contractsByProject, globalResources, resourceAssignmentsByProject, auditLogsByProject, dataLoaded, throttledSave]); // REMOVIDO tasksByProject de las dependencias

  // Limpiar timeout al desmontar el componente
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, []);

  // ===== FUNCIONES DE GESTI√ìN DE PROYECTOS =====
  
  const createProject = (projectData) => {
    const newProject = {
      id: `proj-${Date.now()}`,
      name: projectData.name,
      description: projectData.description,
      startDate: projectData.startDate,
      endDate: projectData.endDate,
      budget: projectData.budget,
      status: projectData.status,
      priority: projectData.priority,
      manager: projectData.manager,
      team: projectData.team,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: '1.0.0',
      progress: 0
    };
    
    setProjects(prev => {
      const updatedProjects = prev.slice();
      updatedProjects.push(newProject);
      return updatedProjects;
    });
    
    // Work Packages eliminados - ya no se usan
    
    setTasksByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[newProject.id] = [];
      return updatedProjects;
    });
    
    setIncludeWeekendsByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[newProject.id] = false; // Por defecto: solo d√≠as laborales
      return updatedProjects;
    });
    
    setRisksByProject(prev => {
      const updatedProjects = Object.assign({}, prev);
      updatedProjects[newProject.id] = [];
      return updatedProjects;
    });
    
    return newProject;
  };

  const updateProject = (projectId, updates) => {
    setProjects(prev => prev.map(project => 
      project.id === projectId 
        ? { 
            id: project.id,
            name: updates.name || project.name,
            description: updates.description || project.description,
            startDate: updates.startDate || project.startDate,
            endDate: updates.endDate || project.endDate,
            budget: updates.budget || project.budget,
            status: updates.status || project.status,
            priority: updates.priority || project.priority,
            manager: updates.manager || project.manager,
            sponsor: updates.sponsor || project.sponsor,
            irr: updates.irr !== undefined ? updates.irr : project.irr,
            objective: updates.objective || project.objective,
            businessCase: updates.businessCase || project.businessCase,
            team: updates.team || project.team,
            createdAt: project.createdAt,
            updatedAt: new Date().toISOString(),
            version: project.version,
            progress: updates.progress || project.progress
          }
        : project
    ));
  };

  const deleteProject = (projectId) => {
    setProjects(prev => prev.filter(project => project.id !== projectId));
    
    // Work Packages eliminados - ya no se usan
    
    setTasksByProject(prev => {
      const newData = Object.assign({}, prev);
      delete newData[projectId];
      return newData;
    });
    
    setRisksByProject(prev => {
      const newData = Object.assign({}, prev);
      delete newData[projectId];
      return newData;
    });
  };

  // ===== FUNCIONES DE WORK PACKAGES =====
  
  // Work Packages eliminados - ya no se usan

  // ===== M√âTRICAS DEL PORTAFOLIO =====
  
  const portfolioMetrics = useMemo(() => {
    const totalProjects = projects.length;
    const activeProjects = projects.filter(p => p.status === 'active').length;
    const completedProjects = projects.filter(p => p.status === 'completed').length;
    const totalBudget = projects.reduce((sum, p) => sum + (p.budget || 0), 0);
    const totalProgress = projects.reduce((sum, p) => sum + (p.progress || 0), 0);
    const averageProgress = totalProjects > 0 ? totalProgress / totalProjects : 0;
    
    return {
      totalProjects,
      activeProjects,
      completedProjects,
      totalBudget,
      averageProgress,
      healthScore: averageProgress > 80 ? 'excellent' : averageProgress > 60 ? 'good' : 'needs_attention'
    };
  }, [projects]);

  // ===== FUNCIONES DE IMPORTACI√ìN/EXPORTACI√ìN =====
  
  const importData = (data) => {
    try {
      if (data.projects) setProjects(data.projects);
      if (data.currentProjectId) setCurrentProjectId(data.currentProjectId);
      if (data.tasksByProject) setTasksByProject(data.tasksByProject);
      if (data.includeWeekendsByProject) setIncludeWeekendsByProject(data.includeWeekendsByProject);
      if (data.risksByProject) setRisksByProject(data.risksByProject);
      if (data.purchaseOrdersByProject) setPurchaseOrdersByProject(data.purchaseOrdersByProject);
      if (data.advancesByProject) setAdvancesByProject(data.advancesByProject);
      if (data.invoicesByProject) setInvoicesByProject(data.invoicesByProject);
      if (data.contractsByProject) setContractsByProject(data.contractsByProject);
      if (data.globalResources) setGlobalResources(data.globalResources);
      if (data.resourceAssignmentsByProject) setResourceAssignmentsByProject(data.resourceAssignmentsByProject);
      if (data.auditLogsByProject) setAuditLogsByProject(data.auditLogsByProject);
      
      // Disparar evento de sincronizaci√≥n
      const syncEvent = new CustomEvent('dataSync', { 
        detail: { 
          type: 'data_imported', 
          timestamp: new Date().toISOString() 
        } 
      });
      window.dispatchEvent(syncEvent);
      
      return true;
      } catch (error) {
      console.error('Error al importar datos:', error);
      return false;
    }
  };

  // ===== ESTADOS DE INTERFAZ =====
  
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  const [showSchedule, setShowSchedule] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [reportingDate, setReportingDate] = useState(new Date().toISOString().split('T')[0]);
  const [showHelp, setShowHelp] = useState(false);
  const [activeSection, setActiveSection] = useState('portfolio');
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false); // Iniciar expandido

  // Funci√≥n para cambiar secci√≥n y colapsar sidebar autom√°ticamente
  const handleSectionChange = (sectionId) => {
    setActiveSection(sectionId);
    setIsSidebarCollapsed(true); // Colapsar sidebar autom√°ticamente
  };

  // Estados de modales
  const [showPOModal, setShowPOModal] = useState(false);
  const [showAdvanceModal, setShowAdvanceModal] = useState(false);
  const [showInvoiceModal, setShowInvoiceModal] = useState(false);
  const [editingPO, setEditingPO] = useState(null);
  const [editingAdvance, setEditingAdvance] = useState(null);
  const [editingInvoice, setEditingInvoice] = useState(null);

  // ===== RENDERIZADO =====
  
  const currentProject = projects.find(p => p.id === currentProjectId);

  return (
    <div className="min-h-screen bg-gray-50">
      <SyncIndicator />
      <FileStatusIndicator />
      <BackupManager onRestoreData={importData} />
      <DataManager 
        onDataImport={importData}
        projects={projects}
        risksByProject={risksByProject}
        tasksByProject={tasksByProject}
        purchaseOrdersByProject={purchaseOrdersByProject}
        advancesByProject={advancesByProject}
        invoicesByProject={invoicesByProject}
        contractsByProject={contractsByProject}
        globalResources={globalResources}
        resourceAssignmentsByProject={resourceAssignmentsByProject}
        viewMode="project"
        currentProjectId={currentProjectId}
      />
      
      <div className="flex">
        <Sidebar 
          activeSection={activeSection}
          onSectionChange={handleSectionChange}
          projects={projects}
          currentProjectId={currentProjectId}
          workPackages={[]}
          risks={getCurrentProjectRisks()}
          isCollapsed={isSidebarCollapsed}
          onToggleCollapse={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
          onSaveAndClose={handleSaveAndClose}
        />
        
        <main className={`flex-1 transition-all duration-300 ${isSidebarCollapsed ? 'ml-16' : 'ml-80 lg:ml-72'}`}>
          <div className={`transition-all duration-300 ${isSidebarCollapsed ? 'p-4' : 'p-6'}`}>
            {/* Dashboard Ejecutivo */}
            {activeSection === 'executive' && (
              <ConsolidatedDashboard 
                projects={projects}
                portfolioMetrics={portfolioMetrics}
                workPackages={[]}
                risks={Object.values(risksByProject).flat()}
                purchaseOrders={Object.values(purchaseOrdersByProject).flat()}
                advances={Object.values(advancesByProject).flat()}
                invoices={Object.values(invoicesByProject).flat()}
                tasksByProject={tasksByProject}
                purchaseOrdersByProject={purchaseOrdersByProject}
                advancesByProject={advancesByProject}
                invoicesByProject={invoicesByProject}
              />
            )}

            {/* Portafolio de Proyectos */}
        {activeSection === 'portfolio' && (
          <PortfolioStrategic
            projects={projects}
            currentProjectId={currentProjectId}
            setCurrentProjectId={setCurrentProjectId}
                workPackages={[]}
                risks={getCurrentProjectRisks()}
                globalResources={globalResources}
                setGlobalResources={setGlobalResources}
            createProject={createProject}
            updateProject={updateProject}
            deleteProject={deleteProject}
                tasks={getCurrentProjectTasks()}
                purchaseOrders={getCurrentProjectPurchaseOrders()}
                advances={getCurrentProjectAdvances()}
                invoices={getCurrentProjectInvoices()}
                contracts={getCurrentProjectContracts()}
                auditLogs={getCurrentProjectAuditLogs()}
              />
            )}

            {/* Gesti√≥n de Proyectos */}
        {activeSection === 'project-management' && (
          <ProjectManagementTabs
            projects={projects}
            currentProjectId={currentProjectId}
            setCurrentProjectId={setCurrentProjectId}
            workPackages={[]}
            setWorkPackages={() => {}}
            risks={getCurrentProjectRisks()}
            setRisks={updateCurrentProjectRisks}
            reportingDate={reportingDate}
            setReportingDate={setReportingDate}
            tasks={getCurrentProjectTasks()}
            setTasks={(newTasksOrUpdater) => {
              // Si es una funci√≥n (setter de React), ejecutarla para obtener el array
              if (typeof newTasksOrUpdater === 'function') {
                const currentTasks = getCurrentProjectTasks();
                const newTasks = newTasksOrUpdater(currentTasks);
                updateCurrentProjectTasks(newTasks);
              } else {
                // Si es directamente un array, pasarlo
                updateCurrentProjectTasks(newTasksOrUpdater);
              }
            }}
            includeWeekends={getCurrentProjectIncludeWeekends()}
            setIncludeWeekends={updateCurrentProjectIncludeWeekends}
            purchaseOrders={getCurrentProjectPurchaseOrders()}
            setPurchaseOrders={updateCurrentProjectPurchaseOrders}
            advances={getCurrentProjectAdvances()}
            setAdvances={updateCurrentProjectAdvances}
            invoices={getCurrentProjectInvoices()}
            setInvoices={updateCurrentProjectInvoices}
            contracts={getCurrentProjectContracts()}
            setContracts={updateCurrentProjectContracts}
            resourceAssignments={getCurrentProjectResourceAssignments()}
              />
            )}
          </div>
        </main>
        </div>
    </div>
  );
}

// Componente principal de la aplicaci√≥n
function App() {
  return (
    <Router>
      <AuthProvider>
        <ProjectProvider>
    <Routes>
            <Route path="/login" element={<LoginForm />} />
      <Route 
        path="/*" 
              element={
                <ProtectedRoute>
                  <MainApp />
                </ProtectedRoute>
              } 
      />
    </Routes>
        </ProjectProvider>
      </AuthProvider>
    </Router>
  );
}

export default App;
