{"version":3,"file":"static/js/555.68312c28.chunk.js","mappings":"8JAaA,MA2EA,EA3E2BA,KACzB,MAAOC,EAAiBC,IAAsBC,EAAAA,EAAAA,UAAS,UAChDC,EAAqBC,IAA0BF,EAAAA,EAAAA,WAAS,IACxDG,EAAoBC,IAAyBJ,EAAAA,EAAAA,WAAS,IAG7DK,EAAAA,EAAAA,WAAU,KACRC,KACC,IAKH,MAAMA,GAA4BC,EAAAA,EAAAA,aAAYC,UAC5CJ,GAAsB,GAEtB,IACE,GAAIK,EAAAA,QAAgBC,kBAAmB,CACrCC,QAAQC,IAAI,kEACZ,MAAMC,QAAoBJ,EAAAA,QAAgBK,oBAC1CZ,EAAuBW,GACvBd,EAAmBc,EAAc,WAAa,SAC9CF,QAAQC,IAAI,wCAADG,OAAoCF,EAAc,WAAa,SAC5E,MACEF,QAAQC,IAAI,oEACZV,GAAuB,GACvBH,EAAmB,QAEvB,CAAE,MAAOiB,GACPL,QAAQK,MAAM,qCAAiCA,GAC/CL,QAAQC,IAAI,mEACZV,GAAuB,GACvBH,EAAmB,QACrB,CAAC,QACCK,GAAsB,EACxB,GACC,IAOGa,GAAwBV,EAAAA,EAAAA,aAAYC,SACvB,aAAbU,GAA4BjB,GAKhCU,QAAQC,IAAI,yDAADG,OAAgDG,IAC3DnB,EAAmBmB,IACZ,IANLP,QAAQQ,KAAK,uEACN,GAMR,CAAClB,IAMEmB,GAAoBb,EAAAA,EAAAA,aAAY,IAC7BN,GAA2C,aAApBH,EAC7B,CAACG,EAAqBH,IAEzB,MAAO,CAELA,kBACAG,sBACAE,qBAGAG,4BACAW,wBACAG,sBC/ESC,EAAc,CACzBC,YAAa,SACbC,mBAAoB,IACpBC,uBAAwB,SACxBC,aAAc,CAAC,MAAO,MAAO,OAAQ,MAAO,MAAO,OAAQ,MAAO,QAClEC,iBAAkB,CAChB,kBACA,aACA,YACA,YACA,qBACA,0EACA,2BACA,sEAkKJ,EAnJ0BC,KAOxB,MAAMC,GAAerB,EAAAA,EAAAA,aAAasB,IAEhC,GAAIA,EAAKC,KAAOT,EAAYC,YAC1B,MAAM,IAAIS,MAAM,6CAADhB,OAA2CM,EAAYC,YAAW,QAAgB,OAInG,MAAMU,EAAgBH,EAAKI,KAAKC,MAAM,KAAKC,MAAMC,cACjD,IAAKf,EAAYI,aAAaY,SAASL,GACrC,MAAM,IAAID,MAAM,mDAADhB,OAAoDM,EAAYI,aAAaa,KAAK,QAInG,IAAKjB,EAAYK,iBAAiBW,SAASR,EAAKU,MAC9C,MAAM,IAAIR,MAAM,gCAGlB,OAAO,GACN,IAQGS,GAAwBjC,EAAAA,EAAAA,aAAY,CAACkC,EAAeC,KAExD,GAAID,EAAcE,QAAUtB,EAAYE,mBACtC,MAAM,IAAIQ,MAAM,8CAADhB,OAAyCM,EAAYE,mBAAkB,2BAKxF,GADkBkB,EAAcG,OAAO,CAACC,EAAKC,IAAMD,GAAOC,EAAEC,UAAY,GAAI,GAAKL,EAAQZ,KACzET,EAAYG,uBAC1B,MAAM,IAAIO,MAAM,+CAADhB,OAAuCM,EAAYG,uBAAsB,QAAgB,qBAEzG,IAOGwB,GAAgBzC,EAAAA,EAAAA,aAAYC,SAE3BqB,EAAKU,KAAKU,WAAW,UAInB,IAAIC,QAASC,IAClB,MAAMC,EAASC,SAASC,cAAc,UAChCC,EAAMH,EAAOI,WAAW,MACxBC,EAAM,IAAIC,MAEhBD,EAAIE,OAAS,KAEX,MAAMC,EAAU,KAChB,IAAI,MAAEC,EAAK,OAAEC,GAAWL,EAEpBI,EAAQC,GAAUD,EAAQD,GAC5BE,EAAUA,EAASF,EAAWC,EAC9BA,EAAQD,GACCE,EAASF,IAClBC,EAASA,EAAQD,EAAWE,EAC5BA,EAASF,GAGXR,EAAOS,MAAQA,EACfT,EAAOU,OAASA,EAEhBP,EAAIQ,UAAUN,EAAK,EAAG,EAAGI,EAAOC,GAEhCV,EAAOY,OAAQC,IACb,MAAMC,EAAiB,IAAIC,KAAK,CAACF,GAAOpC,EAAKI,KAAM,CACjDM,KAAMV,EAAKU,KACX6B,aAAcC,KAAKC,QAErB3D,QAAQC,IAAI,yCAADG,QAA4Bc,EAAKC,KAAO,MAAMyC,QAAQ,GAAE,cAAAxD,QAASmD,EAAepC,KAAO,MAAMyC,QAAQ,GAAE,OAClHpB,EAAQe,IACPrC,EAAKU,KAAM,KAGhBkB,EAAIe,QAAU,KACZ7D,QAAQQ,KAAK,mEACbgC,EAAQtB,IAGV4B,EAAIgB,IAAMC,IAAIC,gBAAgB9C,KAzCvBA,EA2CR,IAOG+C,GAAerE,EAAAA,EAAAA,aAAasB,GACzB,IAAIqB,QAAQ,CAACC,EAAS0B,KAC3B,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,cAAcnD,GACrBiD,EAAOnB,OAAS,IAAMR,EAAQ2B,EAAOG,QACrCH,EAAON,QAAUxD,GAAS6D,EAAO7D,KAElC,IAQGkE,GAAyB3E,EAAAA,EAAAA,aAAYC,eAAOqB,GAA8B,IAAxBY,EAAa0C,UAAAxC,OAAA,QAAAyC,IAAAD,UAAA,GAAAA,UAAA,GAAG,GAEtEvD,EAAaC,GAGbW,EAAsBC,EAAeZ,GAKrC,aAF4BmB,EAAcnB,EAG5C,EAAG,CAACD,EAAcY,EAAuBQ,IAEzC,MAAO,CAELpB,eACAY,wBAGAQ,gBACA4B,eACAM,yBAGA7D,gBC0WJ,EA9dwBgE,IAEtB,MAAOC,EAAOC,IAAYvF,EAAAA,EAAAA,UAAS,KAC5BwF,EAAWC,IAAgBzF,EAAAA,EAAAA,WAAS,IACpCgB,EAAO0E,IAAY1F,EAAAA,EAAAA,UAAS,OAG7B,gBACJF,EAAe,oBACfG,EACAgB,sBAAuB0E,EAAc,kBACrCvE,GACEvB,KAEE,uBACJqF,EAAsB,aACtBN,EACAvD,YAAauE,GACXjE,KAGJtB,EAAAA,EAAAA,WAAU,KACHgF,GACLQ,KACC,CAACR,EAAWvF,EAAiBG,IAKhC,MAAM6F,GAAuBvF,EAAAA,EAAAA,aAAY,KACvC,IACE,MAAMwF,EAAG,iBAAAhF,OAAoBsE,GACvBW,EAAaC,aAAaC,QAAQH,GAExC,GAAIC,EAAY,CACd,MAAMG,EAAcC,KAAKC,MAAML,GAGzBM,EAAgBH,EAAYI,IAAI1E,IAAS,IAAD2E,EAE5C,GAAiB,QAAbA,EAAA3E,EAAK4E,gBAAQ,IAAAD,GAAbA,EAAeE,cAAgB7E,EAAK8E,WAAa9E,EAAK4E,SAASC,aAEjE,OADA/F,QAAQC,IAAI,yCAADG,OAAgCc,EAAK8E,SAAQ,YAAA5F,OAAMc,EAAK4E,SAASC,gBAC5EE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACK/E,GAAI,IACP8E,SAAU9E,EAAK4E,SAASC,aACxBA,aAAc7E,EAAK4E,SAASC,eAKhC,GAAI7E,EAAK6E,cAAgB7E,EAAK8E,WAAa9E,EAAK6E,aAE9C,OADA/F,QAAQC,IAAI,8CAADG,OAAqCc,EAAK8E,SAAQ,YAAA5F,OAAMc,EAAK6E,gBACxEE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACK/E,GAAI,IACP8E,SAAU9E,EAAK6E,eAKnB,GAAI7E,EAAKgF,YAAa,CACpB,MAAMC,EAAYjF,EAAKgF,YAAY3E,MAAM,KAInC6E,EAHkBD,EAAUA,EAAUnE,OAAS,GAGdqE,MAAM,cAC7C,GAAID,GAAkBA,EAAe,KAAOlF,EAAK8E,SAE/C,OADAhG,QAAQC,IAAI,2CAADG,OAAkCc,EAAK8E,SAAQ,YAAA5F,OAAMgG,EAAe,MAC/EH,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACK/E,GAAI,IACP8E,SAAUI,EAAe,GACzBL,aAAcK,EAAe,IAGnC,CAGA,OAAOlF,IAGT0D,EAAS0B,MAAMC,QAAQZ,GAAiBA,EAAgB,IAGpDF,KAAKe,UAAUhB,KAAiBC,KAAKe,UAAUb,KACjDL,aAAamB,QAAQrB,EAAKK,KAAKe,UAAUb,IACzC3F,QAAQC,IAAI,2DAGdD,QAAQC,IAAI,gBAADG,OAAOuF,EAAc3D,OAAM,yCACxC,MACE4C,EAAS,GAEb,CAAE,MAAOvE,GACPL,QAAQK,MAAM,4CAAwCA,GACtDuE,EAAS,GACX,GACC,CAACF,IAKEgC,GAAY9G,EAAAA,EAAAA,aAAa+G,IAC7B,IACE,MAAMvB,EAAG,iBAAAhF,OAAoBsE,GAC7BY,aAAamB,QAAQrB,EAAKK,KAAKe,UAAUG,IACzC3G,QAAQC,IAAI,gBAADG,OAAOuG,EAAS3E,OAAM,uCACnC,CAAE,MAAO3B,GACPL,QAAQK,MAAM,0CAAsCA,EACtD,GACC,CAACqE,IAKEQ,GAAmBtF,EAAAA,EAAAA,aAAYC,UACnC,GAAK6E,EAAL,CAEAI,GAAa,GACbC,EAAS,MAET,IACE,GAAItE,IAAqB,CAEvBT,QAAQC,IAAI,+DAADG,OAAsDsE,EAAS,QAC1E,MAAM,QAAEkC,EAASjC,MAAOkC,EAAexG,MAAOyG,SACtChH,EAAAA,QAAgBiH,iBAAiBrC,GAEzC,GAAIkC,EAAS,CAEX,MAAMI,EAAiBH,EAAcjB,IAAI1E,IAAS,IAAD+F,EAAAC,EAAAC,EAAAC,EAAAC,EAE/C,IAAIC,EAAcpG,EAAK8E,SAGvB,GAAI9E,EAAKgF,aAAe,2BAA2BqB,KAAKrG,EAAK8E,UAAW,CACtE,MAAMG,EAAYjF,EAAKgF,YAAY3E,MAAM,KAInC8E,EAHkBF,EAAUA,EAAUnE,OAAS,GAGvBqE,MAAM,cAChCA,IACFiB,EAAcjB,EAAM,GAExB,CAOA,OAJiB,QAAjBY,EAAI/F,EAAK4E,gBAAQ,IAAAmB,GAAbA,EAAelB,eACjBuB,EAAcpG,EAAK4E,SAASC,eAG9BE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACK/E,GAAI,IACP8E,SAAUsB,EACVvB,aAAcuB,EACdE,UAAuB,QAAbN,EAAAhG,EAAK4E,gBAAQ,IAAAoB,OAAA,EAAbA,EAAeM,WAAY,2BACrCC,aAA0B,QAAbN,EAAAjG,EAAK4E,gBAAQ,IAAAqB,OAAA,EAAbA,EAAeM,cAAe,GAC3CC,eAA4B,QAAbN,EAAAlG,EAAK4E,gBAAQ,IAAAsB,OAAA,EAAbA,EAAeM,gBAAiB,KAC/CC,QAASzG,EAAK0G,UACdvG,eAA2C,QAA5BgG,EAAAC,EAAY/F,MAAM,KAAKC,aAAK,IAAA6F,OAAA,EAA5BA,EAA8B5F,gBAAiB,OAIlEmD,EAASoC,GACThH,QAAQC,IAAI,UAADG,OAAM4G,EAAehF,OAAM,qCACxC,MACEhC,QAAQK,MAAM,wCAAoCyG,GAElD3B,GAEJ,MAEEA,GAEJ,CAAE,MAAO9E,GACPL,QAAQK,MAAM,kCAA8BA,GAC5C0E,EAAS,yCAETI,GACF,CAAC,QACCL,GAAa,EACf,CAjEsB,GAkErB,CAACJ,EAAWjE,EAAmB0E,IAK5B0C,GAAajI,EAAAA,EAAAA,aAAYC,eAAOqB,EAAM4G,EAAUJ,GAAqC,IAAtBD,EAAWjD,UAAAxC,OAAA,QAAAyC,IAAAD,UAAA,GAAAA,UAAA,GAAG,GACjFM,GAAa,GACbC,EAAS,MAET,IAEE,MAAMgD,QAAsBxD,EAAuBrD,EAAMyD,GAEzD,IAAI5C,EAEJ,GAAItB,IAAqB,CAAC,IAADuH,EAEvBhI,QAAQC,IAAI,uDAEZ,MAAM6F,EAAW,CACf2B,cACAC,gBACA3B,aAAc7E,EAAKI,KACnB2G,YAA4C,QAAhCD,EAAAlI,EAAAA,QAAgBoI,wBAAgB,IAAAF,OAAA,EAAhCA,EAAkCG,QAAS,UACvDX,SAAUtG,EAAKU,MAGXwG,QAAqBtI,EAAAA,QAAgBuI,oBACzCN,EACArD,EACAoD,EACAhC,GAgBM,IAADwC,EAbP,IAAIF,EAAaxB,QAcf,MAAM,IAAIxF,MAAM,8BAADhB,QAAiD,QAAlBkI,EAAAF,EAAa/H,aAAK,IAAAiI,OAAA,EAAlBA,EAAoBC,UAAW,sBAdrD,CAAC,IAADC,EACxBzG,GAAOkE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACFmC,EAAalH,MAAI,IACpBuG,cACAC,gBACArG,cAAeH,EAAKI,KAAKC,MAAM,KAAKC,MAAMC,cAC1CwG,YAA4C,QAAhCO,EAAA1I,EAAAA,QAAgBoI,wBAAgB,IAAAM,OAAA,EAAhCA,EAAkCL,QAAS,mBAGzD,MAAMM,EAAe,IAAI9D,EAAO5C,GAChC6C,EAAS6D,GAETzI,QAAQC,IAAI,yDAAqD8B,EAAQiE,SAC3E,CAGF,KAAO,CAELhG,QAAQC,IAAI,mDAGZ,MAAMyI,QAAsBzE,EAAa8D,GAGzChG,EAAU,CACR4G,GAAG,QAADvI,OAAUsD,KAAKC,MAAK,KAAAvD,OAAIwI,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAG,IAC/DrE,YACAoD,WACAJ,gBACA1B,SAAU9E,EAAKI,KACfyE,aAAc7E,EAAKI,KACnBc,SAAU2F,EAAc5G,KACxBqG,SAAUtG,EAAKU,KACfoH,YAAY,IAAItF,MAAOuF,cACvBhB,WAAY,iBACZR,cACAE,QAASe,EACTrH,cAAeH,EAAKI,KAAKC,MAAM,KAAKC,MAAMC,cAC1CqE,SAAU,CACR3G,gBAAiB,UAIrB,MAAMsJ,EAAe,IAAI9D,EAAO5C,GAChC6C,EAAS6D,GACT/B,EAAU+B,GAEVzI,QAAQC,IAAI,qDAAiD8B,EAAQiE,SACvE,CAEA,OAAOjE,CAET,CAAE,MAAO1B,GAGP,MAFAL,QAAQK,MAAM,wBAAyBA,GACvC0E,EAAS1E,EAAMkI,SACTlI,CACR,CAAC,QACCyE,GAAa,EACf,CACF,EAAG,CAACH,EAAOD,EAAWH,EAAwBN,EAAcyC,EAAWjG,IAKjEyI,GAAatJ,EAAAA,EAAAA,aAAYC,UAC7B,IACE,MAAMsJ,EAAexE,EAAMyE,KAAKjH,GAAKA,EAAEwG,KAAOU,GAC9C,IAAKF,EACH,MAAM,IAAI/H,MAAM,yBAIlB,GAAIX,KAAuB0I,EAAajD,YAAa,CACnDlG,QAAQC,IAAI,gEACZ,MAAMqJ,QAAqBxJ,EAAAA,QAAgByJ,sBAAsBJ,EAAajD,aAEzEoD,EAAa1C,QAGhB5G,QAAQC,IAAI,gDAFZD,QAAQQ,KAAK,6DAAoD8I,EAAajJ,MAIlF,CAGA,MAAMoI,EAAe9D,EAAM6E,OAAOrH,GAAKA,EAAEwG,KAAOU,GAChDzE,EAAS6D,GAGe,UAApBtJ,GACFuH,EAAU+B,GAGZzI,QAAQC,IAAI,yCAAqCoJ,EACnD,CAAE,MAAOhJ,GACPL,QAAQK,MAAM,uBAAwBA,GACtC0E,EAAS,4BACX,GACC,CAACJ,EAAO+B,EAAWjG,EAAmBtB,IAKnCsK,GAAqB7J,EAAAA,EAAAA,aAAakI,GACrB,mBAAbA,EACKnD,EAAM6E,OAAOrH,GACH,aAAfA,EAAE2F,UACa,YAAf3F,EAAE2F,UACa,cAAf3F,EAAE2F,UAGCnD,EAAM6E,OAAOrH,GAAKA,EAAE2F,WAAaA,GACvC,CAACnD,IAKE+E,GAAwB9J,EAAAA,EAAAA,aAAa8H,GAClC/C,EAAM6E,OAAOrH,GAAKA,EAAEuF,gBAAkBA,GAC5C,CAAC/C,IAKEgF,GAAc/J,EAAAA,EAAAA,aAAagK,IAC/B,IAAKA,EAAY,OAAOjF,EAExB,MAAMkF,EAAOD,EAAWnI,cACxB,OAAOkD,EAAM6E,OAAOrH,IAAC,IAAA2H,EAAAC,EAAA,OACnB5H,EAAE6D,SAASvE,cAAcC,SAASmI,KACrB,QAD0BC,EACvC3H,EAAEsF,mBAAW,IAAAqC,OAAA,EAAbA,EAAerI,cAAcC,SAASmI,MAC5B,QADiCE,EAC3C5H,EAAE2F,gBAAQ,IAAAiC,OAAA,EAAVA,EAAYtI,cAAcC,SAASmI,OAEpC,CAAClF,IAKEqF,GAAepK,EAAAA,EAAAA,aAAY,KAC/B,MAAMqK,EAAYtF,EAAM1C,OAAO,CAACC,EAAKC,IAAMD,GAAOC,EAAEC,UAAY,GAAI,GAC9D8H,EAAkBvF,EAAM1C,OAAO,CAACkI,EAAKhI,KACzCgI,EAAIhI,EAAE2F,WAAaqC,EAAIhI,EAAE2F,WAAa,GAAK,EACpCqC,GACN,CAAC,GAEJ,MAAO,CACLC,WAAYzF,EAAM3C,OAClBiI,YACAI,aAAcJ,EAAS,SAAkBrG,QAAQ,GACjDsG,kBACAI,gBAAkBL,EAAYvJ,EAAYG,uBAA0B,KAAK+C,QAAQ,KAElF,CAACe,IAKE4F,GAAoB3K,EAAAA,EAAAA,aAAY,KACpCgF,EAAS,IACT,MAAMQ,EAAG,iBAAAhF,OAAoBsE,GAC7BY,aAAakF,WAAWpF,GACxBpF,QAAQC,IAAI,uDACX,CAACyE,IAKEpE,GAAwBV,EAAAA,EAAAA,aAAYC,UACxC,MAAM+G,QAAgB5B,EAAezE,GAKrC,OAJIqG,SAEI1B,IAED0B,GACN,CAAC5B,EAAgBE,IAKduF,GAAmB7K,EAAAA,EAAAA,aAAYC,UACnC,IAAKP,EAEH,OADAU,QAAQQ,KAAK,gDACN,EAGT,IACER,QAAQC,IAAI,4DAGZ,MAAMmF,EAAG,iBAAAhF,OAAoBsE,GACvBW,EAAaC,aAAaC,QAAQH,GAClCsF,EAAarF,EAAaI,KAAKC,MAAML,GAAc,GAEzD,GAA0B,IAAtBqF,EAAW1I,OAEb,OADAhC,QAAQC,IAAI,0DACL,EAGTD,QAAQC,IAAI,8BAADG,OAAqBsK,EAAW1I,OAAM,8BAGjD,IAAK,MAAMd,KAAQwJ,EAEjB,IAAKxJ,EAAKgF,aAAehF,EAAKyG,QAC5B,IAEE,MAAMgD,EAAazJ,EAAKyG,QAAQpG,MAAM,KAAK,GACrCqJ,EAAiBC,KAAKF,GACtBG,EAAc,IAAIxE,MAAMsE,EAAe5I,QAC7C,IAAK,IAAI+I,EAAI,EAAGA,EAAIH,EAAe5I,OAAQ+I,IACzCD,EAAYC,GAAKH,EAAeI,WAAWD,GAE7C,MAAME,EAAY,IAAIC,WAAWJ,GAC3BxH,EAAO,IAAI6H,KAAK,CAACF,GAAY,CAAErJ,KAAMV,EAAKsG,WAC1C4D,EAAa,IAAI5H,KAAK,CAACF,GAAOpC,EAAK8E,SAAU,CAAEpE,KAAMV,EAAKsG,iBAG1DK,EAAWuD,EAAYlK,EAAK4G,SAAU5G,EAAKwG,cAAexG,EAAKuG,YACvE,CAAE,MAAOpH,GACPL,QAAQK,MAAM,sCAADD,OAAkCc,EAAK8E,SAAQ,KAAK3F,EACnE,CAKJ,OADAL,QAAQC,IAAI,wCACL,CAET,CAAE,MAAOI,GAEP,OADAL,QAAQK,MAAM,qCAA8BA,IACrC,CACT,GACC,CAACqE,EAAWpF,EAAqBuI,IAGpC,MAAO,CAELlD,QACAE,YACAxE,QACAlB,kBACAG,sBAGAuI,aACAqB,aACAhE,mBAGAuE,qBACAC,wBACAC,cAGAK,eACAO,oBAGAjK,wBACAmK,mBAGAxF,c","sources":["hooks/useStorageProvider.js","hooks/useFileValidation.js","hooks/useFileStorage.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport supabaseService from '../services/SupabaseService';\n\n/**\n * Hook para gestionar el proveedor de almacenamiento (local/Supabase)\n *\n * Responsabilidades:\n * - Verificar disponibilidad de Supabase\n * - Gestionar el proveedor activo (local/supabase)\n * - Permitir cambio de proveedor\n *\n * @returns {Object} Estado y funciones del proveedor de almacenamiento\n */\nconst useStorageProvider = () => {\n  const [storageProvider, setStorageProvider] = useState('local'); // 'local' o 'supabase'\n  const [isSupabaseAvailable, setIsSupabaseAvailable] = useState(false);\n  const [isCheckingSupabase, setIsCheckingSupabase] = useState(true);\n\n  // Verificar disponibilidad de Supabase al inicializar\n  useEffect(() => {\n    checkSupabaseAvailability();\n  }, []);\n\n  /**\n   * Verifica si Supabase est√° disponible y configura el proveedor\n   */\n  const checkSupabaseAvailability = useCallback(async () => {\n    setIsCheckingSupabase(true);\n\n    try {\n      if (supabaseService.isAuthenticated()) {\n        console.log('üîç Verificando disponibilidad de Supabase Storage...');\n        const isAvailable = await supabaseService.initializeStorage();\n        setIsSupabaseAvailable(isAvailable);\n        setStorageProvider(isAvailable ? 'supabase' : 'local');\n        console.log(`‚úÖ Storage provider configurado: ${isAvailable ? 'Supabase' : 'Local'}`);\n      } else {\n        console.log('‚ö†Ô∏è Usuario no autenticado, usando almacenamiento local');\n        setIsSupabaseAvailable(false);\n        setStorageProvider('local');\n      }\n    } catch (error) {\n      console.error('‚ùå Error verificando Supabase:', error);\n      console.log('üîÑ Fallback a localStorage debido a error de Supabase');\n      setIsSupabaseAvailable(false);\n      setStorageProvider('local');\n    } finally {\n      setIsCheckingSupabase(false);\n    }\n  }, []);\n\n  /**\n   * Cambia el proveedor de almacenamiento\n   * @param {string} provider - 'local' o 'supabase'\n   * @returns {boolean} true si el cambio fue exitoso\n   */\n  const switchStorageProvider = useCallback(async (provider) => {\n    if (provider === 'supabase' && !isSupabaseAvailable) {\n      console.warn('‚ö†Ô∏è No se puede cambiar a Supabase: no est√° disponible');\n      return false;\n    }\n\n    console.log(`üîÑ Cambiando proveedor de almacenamiento a: ${provider}`);\n    setStorageProvider(provider);\n    return true;\n  }, [isSupabaseAvailable]);\n\n  /**\n   * Determina si debe usar Supabase basado en disponibilidad y configuraci√≥n\n   * @returns {boolean}\n   */\n  const shouldUseSupabase = useCallback(() => {\n    return isSupabaseAvailable && storageProvider === 'supabase';\n  }, [isSupabaseAvailable, storageProvider]);\n\n  return {\n    // Estado\n    storageProvider,\n    isSupabaseAvailable,\n    isCheckingSupabase,\n\n    // Funciones\n    checkSupabaseAvailability,\n    switchStorageProvider,\n    shouldUseSupabase,\n  };\n};\n\nexport default useStorageProvider;\n","import { useCallback } from 'react';\n\n/**\n * Configuraci√≥n de l√≠mites para archivos\n */\nexport const FILE_LIMITS = {\n  maxFileSize: 10 * 1024 * 1024, // 10MB\n  maxFilesPerProject: 100,\n  maxTotalSizePerProject: 500 * 1024 * 1024, // 500MB\n  allowedTypes: ['pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'],\n  allowedMimeTypes: [\n    'application/pdf',\n    'image/jpeg',\n    'image/jpg',\n    'image/png',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/vnd.ms-excel',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n  ]\n};\n\n/**\n * Hook para validaci√≥n, compresi√≥n y conversi√≥n de archivos\n *\n * Responsabilidades:\n * - Validar archivos (tama√±o, tipo, MIME)\n * - Comprimir im√°genes autom√°ticamente\n * - Convertir archivos a base64\n * - Validar l√≠mites del proyecto\n *\n * @returns {Object} Funciones de validaci√≥n y procesamiento\n */\nconst useFileValidation = () => {\n  /**\n   * Valida un archivo contra las restricciones configuradas\n   * @param {File} file - Archivo a validar\n   * @throws {Error} Si el archivo no cumple con los requisitos\n   * @returns {boolean} true si la validaci√≥n es exitosa\n   */\n  const validateFile = useCallback((file) => {\n    // Validar tama√±o\n    if (file.size > FILE_LIMITS.maxFileSize) {\n      throw new Error(`El archivo es demasiado grande. M√°ximo ${FILE_LIMITS.maxFileSize / (1024 * 1024)}MB`);\n    }\n\n    // Validar tipo de archivo por extensi√≥n\n    const fileExtension = file.name.split('.').pop().toLowerCase();\n    if (!FILE_LIMITS.allowedTypes.includes(fileExtension)) {\n      throw new Error(`Tipo de archivo no permitido. Tipos permitidos: ${FILE_LIMITS.allowedTypes.join(', ')}`);\n    }\n\n    // Validar MIME type\n    if (!FILE_LIMITS.allowedMimeTypes.includes(file.type)) {\n      throw new Error('Tipo de archivo no v√°lido');\n    }\n\n    return true;\n  }, []);\n\n  /**\n   * Valida l√≠mites del proyecto (cantidad de archivos y tama√±o total)\n   * @param {Array} existingFiles - Archivos existentes en el proyecto\n   * @param {File} newFile - Nuevo archivo a agregar\n   * @throws {Error} Si se exceden los l√≠mites\n   */\n  const validateProjectLimits = useCallback((existingFiles, newFile) => {\n    // Verificar cantidad de archivos\n    if (existingFiles.length >= FILE_LIMITS.maxFilesPerProject) {\n      throw new Error(`L√≠mite de archivos alcanzado. M√°ximo ${FILE_LIMITS.maxFilesPerProject} archivos por proyecto`);\n    }\n\n    // Verificar tama√±o total\n    const totalSize = existingFiles.reduce((sum, f) => sum + (f.fileSize || 0), 0) + newFile.size;\n    if (totalSize > FILE_LIMITS.maxTotalSizePerProject) {\n      throw new Error(`L√≠mite de tama√±o alcanzado. M√°ximo ${FILE_LIMITS.maxTotalSizePerProject / (1024 * 1024)}MB por proyecto`);\n    }\n  }, []);\n\n  /**\n   * Comprime una imagen si es necesario\n   * @param {File} file - Archivo de imagen\n   * @returns {Promise<File>} Archivo comprimido o el original si no es imagen\n   */\n  const compressImage = useCallback(async (file) => {\n    // Si no es imagen, retornar el archivo original\n    if (!file.type.startsWith('image/')) {\n      return file;\n    }\n\n    return new Promise((resolve) => {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      const img = new Image();\n\n      img.onload = () => {\n        // Calcular nuevas dimensiones (m√°ximo 1200px)\n        const maxSize = 1200;\n        let { width, height } = img;\n\n        if (width > height && width > maxSize) {\n          height = (height * maxSize) / width;\n          width = maxSize;\n        } else if (height > maxSize) {\n          width = (width * maxSize) / height;\n          height = maxSize;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        ctx.drawImage(img, 0, 0, width, height);\n\n        canvas.toBlob((blob) => {\n          const compressedFile = new File([blob], file.name, {\n            type: file.type,\n            lastModified: Date.now()\n          });\n          console.log(`üñºÔ∏è Imagen comprimida: ${(file.size / 1024).toFixed(2)}KB ‚Üí ${(compressedFile.size / 1024).toFixed(2)}KB`);\n          resolve(compressedFile);\n        }, file.type, 0.8); // Calidad 80%\n      };\n\n      img.onerror = () => {\n        console.warn('‚ö†Ô∏è Error comprimiendo imagen, usando archivo original');\n        resolve(file);\n      };\n\n      img.src = URL.createObjectURL(file);\n    });\n  }, []);\n\n  /**\n   * Convierte un archivo a base64\n   * @param {File} file - Archivo a convertir\n   * @returns {Promise<string>} Representaci√≥n base64 del archivo\n   */\n  const fileToBase64 = useCallback((file) => {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = error => reject(error);\n    });\n  }, []);\n\n  /**\n   * Valida y procesa un archivo completamente\n   * @param {File} file - Archivo a procesar\n   * @param {Array} existingFiles - Archivos existentes (para validar l√≠mites)\n   * @returns {Promise<File>} Archivo procesado y validado\n   */\n  const validateAndProcessFile = useCallback(async (file, existingFiles = []) => {\n    // Validar archivo\n    validateFile(file);\n\n    // Validar l√≠mites del proyecto\n    validateProjectLimits(existingFiles, file);\n\n    // Comprimir imagen si es necesario\n    const processedFile = await compressImage(file);\n\n    return processedFile;\n  }, [validateFile, validateProjectLimits, compressImage]);\n\n  return {\n    // Funciones de validaci√≥n\n    validateFile,\n    validateProjectLimits,\n\n    // Funciones de procesamiento\n    compressImage,\n    fileToBase64,\n    validateAndProcessFile,\n\n    // Constantes exportadas\n    FILE_LIMITS,\n  };\n};\n\nexport default useFileValidation;\n","import { useState, useEffect, useCallback } from 'react';\nimport supabaseService from '../services/SupabaseService';\nimport useStorageProvider from './useStorageProvider';\nimport useFileValidation, { FILE_LIMITS } from './useFileValidation';\n\n/**\n * Hook principal para gesti√≥n de archivos del proyecto\n *\n * Proporciona funcionalidad completa de gesti√≥n de archivos con soporte para:\n * - Almacenamiento dual: localStorage + Supabase Storage\n * - Validaci√≥n autom√°tica de archivos (tama√±o, tipo, l√≠mites)\n * - Compresi√≥n autom√°tica de im√°genes\n * - Categorizaci√≥n de archivos\n * - B√∫squeda y filtrado\n * - Sincronizaci√≥n entre proveedores\n *\n * Refactorizado para usar hooks especializados:\n * - useStorageProvider: Gesti√≥n del proveedor de almacenamiento\n * - useFileValidation: Validaci√≥n y procesamiento de archivos\n *\n * @param {string} projectId - ID del proyecto\n *\n * @returns {Object} Estado y funciones para gesti√≥n de archivos\n * @returns {Array<Object>} return.files - Lista de archivos del proyecto\n * @returns {boolean} return.isLoading - Estado de carga\n * @returns {string|null} return.error - Mensaje de error si existe\n * @returns {string} return.storageProvider - Proveedor activo ('local' o 'supabase')\n * @returns {boolean} return.isSupabaseAvailable - Si Supabase Storage est√° disponible\n * @returns {Function} return.uploadFile - Sube un archivo al proyecto\n * @returns {Function} return.deleteFile - Elimina un archivo\n * @returns {Function} return.loadProjectFiles - Recarga archivos del proyecto\n * @returns {Function} return.getFilesByCategory - Filtra archivos por categor√≠a\n * @returns {Function} return.getFilesByRelatedItem - Filtra archivos por item relacionado\n * @returns {Function} return.searchFiles - Busca archivos por nombre\n * @returns {Function} return.getFileStats - Obtiene estad√≠sticas de archivos\n * @returns {Function} return.clearProjectFiles - Limpia archivos del proyecto\n * @returns {Function} return.switchStorageProvider - Cambia proveedor de almacenamiento\n * @returns {Function} return.syncWithSupabase - Sincroniza archivos con Supabase\n * @returns {Object} return.fileLimits - L√≠mites de archivos (tama√±o, cantidad, tipos)\n *\n * @example\n * const {\n *   files,\n *   isLoading,\n *   uploadFile,\n *   deleteFile,\n *   getFilesByCategory\n * } = useFileStorage(projectId);\n *\n * // Subir archivo\n * const handleUpload = async (file) => {\n *   const result = await uploadFile(file, 'contract', 'Contrato principal');\n *   if (result.success) {\n *     console.log('Archivo subido:', result.file);\n *   }\n * };\n *\n * // Obtener archivos de una categor√≠a\n * const contracts = getFilesByCategory('contract');\n */\nconst useFileStorage = (projectId) => {\n  // Estado local\n  const [files, setFiles] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Hooks especializados\n  const {\n    storageProvider,\n    isSupabaseAvailable,\n    switchStorageProvider: switchProvider,\n    shouldUseSupabase,\n  } = useStorageProvider();\n\n  const {\n    validateAndProcessFile,\n    fileToBase64,\n    FILE_LIMITS: fileLimits,\n  } = useFileValidation();\n\n  // Cargar archivos del proyecto al montar o cambiar proyecto/proveedor\n  useEffect(() => {\n    if (!projectId) return;\n    loadProjectFiles();\n  }, [projectId, storageProvider, isSupabaseAvailable]);\n\n  /**\n   * Carga archivos desde localStorage\n   */\n  const loadFromLocalStorage = useCallback(() => {\n    try {\n      const key = `project-files-${projectId}`;\n      const savedFiles = localStorage.getItem(key);\n\n      if (savedFiles) {\n        const parsedFiles = JSON.parse(savedFiles);\n\n        // Migrar nombres de archivos antiguos autom√°ticamente\n        const migratedFiles = parsedFiles.map(file => {\n          // 1. Si hay originalName en metadata, tiene m√°xima prioridad\n          if (file.metadata?.originalName && file.fileName !== file.metadata.originalName) {\n            console.log(`üîÑ Migrando desde metadata: ${file.fileName} ‚Üí ${file.metadata.originalName}`);\n            return {\n              ...file,\n              fileName: file.metadata.originalName,\n              originalName: file.metadata.originalName\n            };\n          }\n\n          // 2. Si tiene originalName directamente pero fileName es diferente, corregir\n          if (file.originalName && file.fileName !== file.originalName) {\n            console.log(`üîÑ Corrigiendo con originalName: ${file.fileName} ‚Üí ${file.originalName}`);\n            return {\n              ...file,\n              fileName: file.originalName\n            };\n          }\n\n          // 3. Si tiene storagePath, intentar extraer el nombre original de ah√≠\n          if (file.storagePath) {\n            const pathParts = file.storagePath.split('/');\n            const storageFileName = pathParts[pathParts.length - 1];\n\n            // Intentar extraer nombre original (formato: timestamp-nombre-original.ext)\n            const timestampMatch = storageFileName.match(/^\\d+-(.+)$/);\n            if (timestampMatch && timestampMatch[1] !== file.fileName) {\n              console.log(`üîÑ Extrayendo de storagePath: ${file.fileName} ‚Üí ${timestampMatch[1]}`);\n              return {\n                ...file,\n                fileName: timestampMatch[1],\n                originalName: timestampMatch[1]\n              };\n            }\n          }\n\n          // Si ya est√° correcto o no se pudo migrar, mantenerlo\n          return file;\n        });\n\n        setFiles(Array.isArray(migratedFiles) ? migratedFiles : []);\n\n        // Si hubo cambios, guardar la versi√≥n migrada\n        if (JSON.stringify(parsedFiles) !== JSON.stringify(migratedFiles)) {\n          localStorage.setItem(key, JSON.stringify(migratedFiles));\n          console.log(`‚ú® Nombres de archivos migrados autom√°ticamente`);\n        }\n\n        console.log(`üìÇ ${migratedFiles.length} archivos cargados desde localStorage`);\n      } else {\n        setFiles([]);\n      }\n    } catch (error) {\n      console.error('‚ùå Error cargando desde localStorage:', error);\n      setFiles([]);\n    }\n  }, [projectId]);\n\n  /**\n   * Guarda archivos en localStorage\n   */\n  const saveFiles = useCallback((fileList) => {\n    try {\n      const key = `project-files-${projectId}`;\n      localStorage.setItem(key, JSON.stringify(fileList));\n      console.log(`üíæ ${fileList.length} archivos guardados en localStorage`);\n    } catch (error) {\n      console.error('‚ùå Error guardando en localStorage:', error);\n    }\n  }, [projectId]);\n\n  /**\n   * Carga archivos del proyecto seg√∫n el proveedor de almacenamiento\n   */\n  const loadProjectFiles = useCallback(async () => {\n    if (!projectId) return;\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      if (shouldUseSupabase()) {\n        // Cargar desde Supabase Storage\n        console.log(`üìÇ Cargando archivos desde Supabase para proyecto ${projectId}...`);\n        const { success, files: supabaseFiles, error: supabaseError } =\n          await supabaseService.listProjectFiles(projectId);\n\n        if (success) {\n          // Convertir archivos de Supabase al formato esperado\n          const convertedFiles = supabaseFiles.map(file => {\n            // Intentar extraer el nombre original del storagePath si fileName no lo tiene\n            let displayName = file.fileName;\n\n            // Si el fileName parece ser un ID (timestamp-randomId.ext), extraer el nombre del storagePath\n            if (file.storagePath && /^\\d+-[a-z0-9]+\\.[a-z]+$/i.test(file.fileName)) {\n              const pathParts = file.storagePath.split('/');\n              const storageFileName = pathParts[pathParts.length - 1];\n\n              // Intentar extraer el nombre original (formato: timestamp-nombre-original.ext)\n              const match = storageFileName.match(/^\\d+-(.+)$/);\n              if (match) {\n                displayName = match[1]; // Usar el nombre despu√©s del timestamp\n              }\n            }\n\n            // Si hay originalName en metadata, usarlo (tiene prioridad)\n            if (file.metadata?.originalName) {\n              displayName = file.metadata.originalName;\n            }\n\n            return {\n              ...file,\n              fileName: displayName,\n              originalName: displayName,\n              mimeType: file.metadata?.mimeType || 'application/octet-stream',\n              description: file.metadata?.description || '',\n              relatedItemId: file.metadata?.relatedItemId || null,\n              content: file.publicUrl,\n              fileExtension: displayName.split('.').pop()?.toLowerCase() || ''\n            };\n          });\n\n          setFiles(convertedFiles);\n          console.log(`‚úÖ ${convertedFiles.length} archivos cargados desde Supabase`);\n        } else {\n          console.error('‚ùå Error cargando desde Supabase:', supabaseError);\n          // Fallback a localStorage\n          loadFromLocalStorage();\n        }\n      } else {\n        // Cargar desde localStorage\n        loadFromLocalStorage();\n      }\n    } catch (error) {\n      console.error('‚ùå Error cargando archivos:', error);\n      setError('Error al cargar archivos del proyecto');\n      // Fallback a localStorage en caso de error\n      loadFromLocalStorage();\n    } finally {\n      setIsLoading(false);\n    }\n  }, [projectId, shouldUseSupabase, loadFromLocalStorage]);\n\n  /**\n   * Sube un archivo al proyecto\n   */\n  const uploadFile = useCallback(async (file, category, relatedItemId, description = '') => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Validar y procesar archivo (validaci√≥n + compresi√≥n)\n      const processedFile = await validateAndProcessFile(file, files);\n\n      let newFile;\n\n      if (shouldUseSupabase()) {\n        // Subir a Supabase Storage\n        console.log('‚òÅÔ∏è Subiendo archivo a Supabase Storage...');\n\n        const metadata = {\n          description,\n          relatedItemId,\n          originalName: file.name,\n          uploadedBy: supabaseService.getCurrentUser()?.email || 'Usuario',\n          mimeType: file.type\n        };\n\n        const uploadResult = await supabaseService.uploadFileToStorage(\n          processedFile,\n          projectId,\n          category,\n          metadata\n        );\n\n        if (uploadResult.success) {\n          newFile = {\n            ...uploadResult.file,\n            description,\n            relatedItemId,\n            fileExtension: file.name.split('.').pop().toLowerCase(),\n            uploadedBy: supabaseService.getCurrentUser()?.email || 'Usuario Actual'\n          };\n\n          const updatedFiles = [...files, newFile];\n          setFiles(updatedFiles);\n\n          console.log('‚úÖ Archivo subido exitosamente a Supabase Storage:', newFile.fileName);\n        } else {\n          throw new Error(`Error subiendo a Supabase: ${uploadResult.error?.message || 'Error desconocido'}`);\n        }\n      } else {\n        // Subir a localStorage\n        console.log('üíæ Subiendo archivo a localStorage...');\n\n        // Convertir a base64\n        const base64Content = await fileToBase64(processedFile);\n\n        // Crear objeto de archivo\n        newFile = {\n          id: `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          projectId,\n          category,\n          relatedItemId,\n          fileName: file.name,\n          originalName: file.name,\n          fileSize: processedFile.size,\n          mimeType: file.type,\n          uploadDate: new Date().toISOString(),\n          uploadedBy: 'Usuario Actual',\n          description,\n          content: base64Content,\n          fileExtension: file.name.split('.').pop().toLowerCase(),\n          metadata: {\n            storageProvider: 'local'\n          }\n        };\n\n        const updatedFiles = [...files, newFile];\n        setFiles(updatedFiles);\n        saveFiles(updatedFiles);\n\n        console.log('‚úÖ Archivo subido exitosamente a localStorage:', newFile.fileName);\n      }\n\n      return newFile;\n\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      setError(error.message);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [files, projectId, validateAndProcessFile, fileToBase64, saveFiles, shouldUseSupabase]);\n\n  /**\n   * Elimina un archivo del proyecto\n   */\n  const deleteFile = useCallback(async (fileId) => {\n    try {\n      const fileToDelete = files.find(f => f.id === fileId);\n      if (!fileToDelete) {\n        throw new Error('Archivo no encontrado');\n      }\n\n      // Eliminar de Supabase si corresponde\n      if (shouldUseSupabase() && fileToDelete.storagePath) {\n        console.log('üóëÔ∏è Eliminando archivo de Supabase Storage...');\n        const deleteResult = await supabaseService.deleteFileFromStorage(fileToDelete.storagePath);\n\n        if (!deleteResult.success) {\n          console.warn('‚ö†Ô∏è Error eliminando archivo de Supabase Storage:', deleteResult.error);\n        } else {\n          console.log('‚úÖ Archivo eliminado de Supabase Storage');\n        }\n      }\n\n      // Eliminar de la lista local\n      const updatedFiles = files.filter(f => f.id !== fileId);\n      setFiles(updatedFiles);\n\n      // Guardar en localStorage si corresponde\n      if (storageProvider === 'local') {\n        saveFiles(updatedFiles);\n      }\n\n      console.log('‚úÖ Archivo eliminado exitosamente:', fileId);\n    } catch (error) {\n      console.error('Error deleting file:', error);\n      setError('Error al eliminar archivo');\n    }\n  }, [files, saveFiles, shouldUseSupabase, storageProvider]);\n\n  /**\n   * Obtiene archivos por categor√≠a\n   */\n  const getFilesByCategory = useCallback((category) => {\n    if (category === 'financial-only') {\n      return files.filter(f =>\n        f.category === 'contract' ||\n        f.category === 'invoice' ||\n        f.category === 'financial'\n      );\n    }\n    return files.filter(f => f.category === category);\n  }, [files]);\n\n  /**\n   * Obtiene archivos por item relacionado\n   */\n  const getFilesByRelatedItem = useCallback((relatedItemId) => {\n    return files.filter(f => f.relatedItemId === relatedItemId);\n  }, [files]);\n\n  /**\n   * Busca archivos por t√©rmino de b√∫squeda\n   */\n  const searchFiles = useCallback((searchTerm) => {\n    if (!searchTerm) return files;\n\n    const term = searchTerm.toLowerCase();\n    return files.filter(f =>\n      f.fileName.toLowerCase().includes(term) ||\n      f.description?.toLowerCase().includes(term) ||\n      f.category?.toLowerCase().includes(term)\n    );\n  }, [files]);\n\n  /**\n   * Obtiene estad√≠sticas de archivos del proyecto\n   */\n  const getFileStats = useCallback(() => {\n    const totalSize = files.reduce((sum, f) => sum + (f.fileSize || 0), 0);\n    const filesByCategory = files.reduce((acc, f) => {\n      acc[f.category] = (acc[f.category] || 0) + 1;\n      return acc;\n    }, {});\n\n    return {\n      totalFiles: files.length,\n      totalSize,\n      totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),\n      filesByCategory,\n      percentageUsed: ((totalSize / FILE_LIMITS.maxTotalSizePerProject) * 100).toFixed(1)\n    };\n  }, [files]);\n\n  /**\n   * Limpia todos los archivos del proyecto\n   */\n  const clearProjectFiles = useCallback(() => {\n    setFiles([]);\n    const key = `project-files-${projectId}`;\n    localStorage.removeItem(key);\n    console.log('üóëÔ∏è Archivos del proyecto limpiados');\n  }, [projectId]);\n\n  /**\n   * Cambia el proveedor de almacenamiento\n   */\n  const switchStorageProvider = useCallback(async (provider) => {\n    const success = await switchProvider(provider);\n    if (success) {\n      // Recargar archivos del nuevo proveedor\n      await loadProjectFiles();\n    }\n    return success;\n  }, [switchProvider, loadProjectFiles]);\n\n  /**\n   * Sincroniza archivos locales con Supabase\n   */\n  const syncWithSupabase = useCallback(async () => {\n    if (!isSupabaseAvailable) {\n      console.warn('‚ö†Ô∏è Supabase no est√° disponible');\n      return false;\n    }\n\n    try {\n      console.log('üîÑ Iniciando sincronizaci√≥n con Supabase...');\n\n      // Cargar archivos locales\n      const key = `project-files-${projectId}`;\n      const savedFiles = localStorage.getItem(key);\n      const localFiles = savedFiles ? JSON.parse(savedFiles) : [];\n\n      if (localFiles.length === 0) {\n        console.log('üìÇ No hay archivos locales para sincronizar');\n        return true;\n      }\n\n      console.log(`üì§ Sincronizando ${localFiles.length} archivos con Supabase...`);\n\n      // Subir cada archivo local a Supabase\n      for (const file of localFiles) {\n        // Solo sincronizar archivos que no est√©n ya en Supabase\n        if (!file.storagePath && file.content) {\n          try {\n            // Reconstruir File object desde base64\n            const base64Data = file.content.split(',')[1];\n            const byteCharacters = atob(base64Data);\n            const byteNumbers = new Array(byteCharacters.length);\n            for (let i = 0; i < byteCharacters.length; i++) {\n              byteNumbers[i] = byteCharacters.charCodeAt(i);\n            }\n            const byteArray = new Uint8Array(byteNumbers);\n            const blob = new Blob([byteArray], { type: file.mimeType });\n            const fileObject = new File([blob], file.fileName, { type: file.mimeType });\n\n            // Subir a Supabase\n            await uploadFile(fileObject, file.category, file.relatedItemId, file.description);\n          } catch (error) {\n            console.error(`‚ùå Error sincronizando archivo ${file.fileName}:`, error);\n          }\n        }\n      }\n\n      console.log('‚úÖ Sincronizaci√≥n completada');\n      return true;\n\n    } catch (error) {\n      console.error('‚ùå Error en sincronizaci√≥n:', error);\n      return false;\n    }\n  }, [projectId, isSupabaseAvailable, uploadFile]);\n\n  // API p√∫blica del hook\n  return {\n    // Estado\n    files,\n    isLoading,\n    error,\n    storageProvider,\n    isSupabaseAvailable,\n\n    // Funciones de gesti√≥n de archivos\n    uploadFile,\n    deleteFile,\n    loadProjectFiles,\n\n    // Funciones de b√∫squeda y filtrado\n    getFilesByCategory,\n    getFilesByRelatedItem,\n    searchFiles,\n\n    // Funciones de utilidad\n    getFileStats,\n    clearProjectFiles,\n\n    // Funciones de proveedor\n    switchStorageProvider,\n    syncWithSupabase,\n\n    // Constantes\n    fileLimits,\n  };\n};\n\nexport default useFileStorage;\n"],"names":["useStorageProvider","storageProvider","setStorageProvider","useState","isSupabaseAvailable","setIsSupabaseAvailable","isCheckingSupabase","setIsCheckingSupabase","useEffect","checkSupabaseAvailability","useCallback","async","supabaseService","isAuthenticated","console","log","isAvailable","initializeStorage","concat","error","switchStorageProvider","provider","warn","shouldUseSupabase","FILE_LIMITS","maxFileSize","maxFilesPerProject","maxTotalSizePerProject","allowedTypes","allowedMimeTypes","useFileValidation","validateFile","file","size","Error","fileExtension","name","split","pop","toLowerCase","includes","join","type","validateProjectLimits","existingFiles","newFile","length","reduce","sum","f","fileSize","compressImage","startsWith","Promise","resolve","canvas","document","createElement","ctx","getContext","img","Image","onload","maxSize","width","height","drawImage","toBlob","blob","compressedFile","File","lastModified","Date","now","toFixed","onerror","src","URL","createObjectURL","fileToBase64","reject","reader","FileReader","readAsDataURL","result","validateAndProcessFile","arguments","undefined","projectId","files","setFiles","isLoading","setIsLoading","setError","switchProvider","fileLimits","loadProjectFiles","loadFromLocalStorage","key","savedFiles","localStorage","getItem","parsedFiles","JSON","parse","migratedFiles","map","_file$metadata","metadata","originalName","fileName","_objectSpread","storagePath","pathParts","timestampMatch","match","Array","isArray","stringify","setItem","saveFiles","fileList","success","supabaseFiles","supabaseError","listProjectFiles","convertedFiles","_file$metadata2","_file$metadata3","_file$metadata4","_file$metadata5","_displayName$split$po","displayName","test","mimeType","description","relatedItemId","content","publicUrl","uploadFile","category","processedFile","_supabaseService$getC","uploadedBy","getCurrentUser","email","uploadResult","uploadFileToStorage","_uploadResult$error","message","_supabaseService$getC2","updatedFiles","base64Content","id","Math","random","toString","substr","uploadDate","toISOString","deleteFile","fileToDelete","find","fileId","deleteResult","deleteFileFromStorage","filter","getFilesByCategory","getFilesByRelatedItem","searchFiles","searchTerm","term","_f$description","_f$category","getFileStats","totalSize","filesByCategory","acc","totalFiles","totalSizeMB","percentageUsed","clearProjectFiles","removeItem","syncWithSupabase","localFiles","base64Data","byteCharacters","atob","byteNumbers","i","charCodeAt","byteArray","Uint8Array","Blob","fileObject"],"sourceRoot":""}